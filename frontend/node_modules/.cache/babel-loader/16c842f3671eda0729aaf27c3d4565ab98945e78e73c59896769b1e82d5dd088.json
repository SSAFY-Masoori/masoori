{"ast":null,"code":"import _extends from '@babel/runtime/helpers/esm/extends';\nimport * as THREE from 'three';\nimport * as React from 'react';\nimport { shaderMaterial } from './shaderMaterial.js';\nimport { extend, applyProps } from '@react-three/fiber';\nimport { toCreasedNormals } from 'three-stdlib';\nconst OutlinesMaterial = shaderMaterial({\n  color: new THREE.Color('black'),\n  opacity: 1,\n  thickness: 0.05\n}, `#include <common>\n   #include <morphtarget_pars_vertex>\n   #include <skinning_pars_vertex>\n   uniform float thickness;\n   void main() {\n     #if defined (USE_SKINNING)\n\t     #include <beginnormal_vertex>\n       #include <morphnormal_vertex>\n       #include <skinbase_vertex>\n       #include <skinnormal_vertex>\n       #include <defaultnormal_vertex>\n     #endif\n     #include <begin_vertex>\n\t   #include <morphtarget_vertex>\n\t   #include <skinning_vertex>\n     #include <project_vertex>\n     vec4 transformedNormal = vec4(normal, 0.0);\n     vec4 transformedPosition = vec4(transformed, 1.0);\n     #ifdef USE_INSTANCING\n       transformedNormal = instanceMatrix * transformedNormal;\n       transformedPosition = instanceMatrix * transformedPosition;\n     #endif\n     vec3 newPosition = transformedPosition.xyz + transformedNormal.xyz * thickness;\n     gl_Position = projectionMatrix * modelViewMatrix * vec4(newPosition, 1.0); \n   }`, `uniform vec3 color;\n   uniform float opacity;\n   void main(){\n     gl_FragColor = vec4(color, opacity);\n     #include <tonemapping_fragment>\n     #include <${parseInt(THREE.REVISION.replace(/\\D+/g, '')) >= 154 ? 'colorspace_fragment' : 'encodings_fragment'}>\n   }`);\nfunction Outlines({\n  color = 'black',\n  opacity = 1,\n  transparent = false,\n  thickness = 0.05,\n  angle = Math.PI,\n  ...props\n}) {\n  var _ref$current, _ref$current$parent;\n  const ref = React.useRef(null);\n  const [material] = React.useState(() => new OutlinesMaterial({\n    side: THREE.BackSide\n  }));\n  React.useMemo(() => extend({\n    OutlinesMaterial\n  }), []);\n  React.useLayoutEffect(() => {\n    const group = ref.current;\n    const parent = group.parent;\n    if (parent && parent.geometry) {\n      let mesh;\n      if (parent.skeleton) {\n        mesh = new THREE.SkinnedMesh();\n        mesh.material = material;\n        mesh.bind(parent.skeleton, parent.bindMatrix);\n        group.add(mesh);\n      } else if (parent.isInstancedMesh) {\n        mesh = new THREE.InstancedMesh(parent.geometry, material, parent.count);\n        mesh.instanceMatrix = parent.instanceMatrix;\n        group.add(mesh);\n      } else {\n        mesh = new THREE.Mesh();\n        mesh.material = material;\n        group.add(mesh);\n      }\n      mesh.geometry = angle ? toCreasedNormals(parent.geometry, angle) : parent.geometry;\n      return () => {\n        if (angle) mesh.geometry.dispose();\n        group.remove(mesh);\n      };\n    }\n  }, [angle, (_ref$current = ref.current) == null ? void 0 : (_ref$current$parent = _ref$current.parent) == null ? void 0 : _ref$current$parent.geometry]);\n  React.useLayoutEffect(() => {\n    const group = ref.current;\n    const mesh = group.children[0];\n    if (mesh) {\n      applyProps(mesh.material, {\n        transparent,\n        thickness,\n        color,\n        opacity\n      });\n    }\n  }, [angle, transparent, thickness, color, opacity]);\n  return /*#__PURE__*/React.createElement(\"group\", _extends({\n    ref: ref\n  }, props));\n}\nexport { Outlines };","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}