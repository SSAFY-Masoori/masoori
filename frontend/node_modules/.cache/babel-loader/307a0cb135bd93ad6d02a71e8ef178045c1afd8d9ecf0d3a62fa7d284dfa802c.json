{"ast":null,"code":"// drag\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('./core'), require('unidragger'), require('fizzy-ui-utils'));\n  } else {\n    // browser global\n    window.Flickity = factory(window, window.Flickity, window.Unidragger, window.fizzyUIUtils);\n  }\n})(typeof window != 'undefined' ? window : this, function factory(window, Flickity, Unidragger, utils) {\n  // ----- defaults ----- //\n\n  Object.assign(Flickity.defaults, {\n    draggable: '>1',\n    dragThreshold: 3\n  });\n\n  // -------------------------- drag prototype -------------------------- //\n\n  let proto = Flickity.prototype;\n  Object.assign(proto, Unidragger.prototype); // inherit Unidragger\n  proto.touchActionValue = '';\n\n  // --------------------------  -------------------------- //\n\n  Flickity.create.drag = function () {\n    this.on('activate', this.onActivateDrag);\n    this.on('uiChange', this._uiChangeDrag);\n    this.on('deactivate', this.onDeactivateDrag);\n    this.on('cellChange', this.updateDraggable);\n    this.on('pointerDown', this.handlePointerDown);\n    this.on('pointerUp', this.handlePointerUp);\n    this.on('pointerDown', this.handlePointerDone);\n    this.on('dragStart', this.handleDragStart);\n    this.on('dragMove', this.handleDragMove);\n    this.on('dragEnd', this.handleDragEnd);\n    this.on('staticClick', this.handleStaticClick);\n    // TODO updateDraggable on resize? if groupCells & slides change\n  };\n\n  proto.onActivateDrag = function () {\n    this.handles = [this.viewport];\n    this.bindHandles();\n    this.updateDraggable();\n  };\n  proto.onDeactivateDrag = function () {\n    this.unbindHandles();\n    this.element.classList.remove('is-draggable');\n  };\n  proto.updateDraggable = function () {\n    // disable dragging if less than 2 slides. #278\n    if (this.options.draggable === '>1') {\n      this.isDraggable = this.slides.length > 1;\n    } else {\n      this.isDraggable = this.options.draggable;\n    }\n    this.element.classList.toggle('is-draggable', this.isDraggable);\n  };\n  proto._uiChangeDrag = function () {\n    delete this.isFreeScrolling;\n  };\n\n  // -------------------------- pointer events -------------------------- //\n\n  proto.handlePointerDown = function (event) {\n    if (!this.isDraggable) {\n      // proceed for staticClick\n      this.bindActivePointerEvents(event);\n      return;\n    }\n    let isTouchStart = event.type === 'touchstart';\n    let isTouchPointer = event.pointerType === 'touch';\n    let isFocusNode = event.target.matches('input, textarea, select');\n    if (!isTouchStart && !isTouchPointer && !isFocusNode) event.preventDefault();\n    if (!isFocusNode) this.focus();\n    // blur\n    if (document.activeElement !== this.element) document.activeElement.blur();\n    // stop if it was moving\n    this.dragX = this.x;\n    this.viewport.classList.add('is-pointer-down');\n    // track scrolling\n    this.pointerDownScroll = getScrollPosition();\n    window.addEventListener('scroll', this);\n    this.bindActivePointerEvents(event);\n  };\n\n  // ----- move ----- //\n\n  proto.hasDragStarted = function (moveVector) {\n    return Math.abs(moveVector.x) > this.options.dragThreshold;\n  };\n\n  // ----- up ----- //\n\n  proto.handlePointerUp = function () {\n    delete this.isTouchScrolling;\n    this.viewport.classList.remove('is-pointer-down');\n  };\n  proto.handlePointerDone = function () {\n    window.removeEventListener('scroll', this);\n    delete this.pointerDownScroll;\n  };\n\n  // -------------------------- dragging -------------------------- //\n\n  proto.handleDragStart = function () {\n    if (!this.isDraggable) return;\n    this.dragStartPosition = this.x;\n    this.startAnimation();\n    window.removeEventListener('scroll', this);\n  };\n  proto.handleDragMove = function (event, pointer, moveVector) {\n    if (!this.isDraggable) return;\n    event.preventDefault();\n    this.previousDragX = this.dragX;\n    // reverse if right-to-left\n    let direction = this.options.rightToLeft ? -1 : 1;\n    // wrap around move. #589\n    if (this.isWrapping) moveVector.x %= this.slideableWidth;\n    let dragX = this.dragStartPosition + moveVector.x * direction;\n    if (!this.isWrapping) {\n      // slow drag\n      let originBound = Math.max(-this.slides[0].target, this.dragStartPosition);\n      dragX = dragX > originBound ? (dragX + originBound) * 0.5 : dragX;\n      let endBound = Math.min(-this.getLastSlide().target, this.dragStartPosition);\n      dragX = dragX < endBound ? (dragX + endBound) * 0.5 : dragX;\n    }\n    this.dragX = dragX;\n    this.dragMoveTime = new Date();\n  };\n  proto.handleDragEnd = function () {\n    if (!this.isDraggable) return;\n    let {\n      freeScroll\n    } = this.options;\n    if (freeScroll) this.isFreeScrolling = true;\n    // set selectedIndex based on where flick will end up\n    let index = this.dragEndRestingSelect();\n    if (freeScroll && !this.isWrapping) {\n      // if free-scroll & not wrap around\n      // do not free-scroll if going outside of bounding slides\n      // so bounding slides can attract slider, and keep it in bounds\n      let restingX = this.getRestingPosition();\n      this.isFreeScrolling = -restingX > this.slides[0].target && -restingX < this.getLastSlide().target;\n    } else if (!freeScroll && index === this.selectedIndex) {\n      // boost selection if selected index has not changed\n      index += this.dragEndBoostSelect();\n    }\n    delete this.previousDragX;\n    // apply selection\n    // HACK, set flag so dragging stays in correct direction\n    this.isDragSelect = this.isWrapping;\n    this.select(index);\n    delete this.isDragSelect;\n  };\n  proto.dragEndRestingSelect = function () {\n    let restingX = this.getRestingPosition();\n    // how far away from selected slide\n    let distance = Math.abs(this.getSlideDistance(-restingX, this.selectedIndex));\n    // get closet resting going up and going down\n    let positiveResting = this._getClosestResting(restingX, distance, 1);\n    let negativeResting = this._getClosestResting(restingX, distance, -1);\n    // use closer resting for wrap-around\n    return positiveResting.distance < negativeResting.distance ? positiveResting.index : negativeResting.index;\n  };\n\n  /**\n   * given resting X and distance to selected cell\n   * get the distance and index of the closest cell\n   * @param {Number} restingX - estimated post-flick resting position\n   * @param {Number} distance - distance to selected cell\n   * @param {Integer} increment - +1 or -1, going up or down\n   * @returns {Object} - { distance: {Number}, index: {Integer} }\n   */\n  proto._getClosestResting = function (restingX, distance, increment) {\n    let index = this.selectedIndex;\n    let minDistance = Infinity;\n    let condition = this.options.contain && !this.isWrapping ?\n    // if containing, keep going if distance is equal to minDistance\n    (dist, minDist) => dist <= minDist : (dist, minDist) => dist < minDist;\n    while (condition(distance, minDistance)) {\n      // measure distance to next cell\n      index += increment;\n      minDistance = distance;\n      distance = this.getSlideDistance(-restingX, index);\n      if (distance === null) break;\n      distance = Math.abs(distance);\n    }\n    return {\n      distance: minDistance,\n      // selected was previous index\n      index: index - increment\n    };\n  };\n\n  /**\n   * measure distance between x and a slide target\n   * @param {Number} x - horizontal position\n   * @param {Integer} index - slide index\n   * @returns {Number} - slide distance\n   */\n  proto.getSlideDistance = function (x, index) {\n    let len = this.slides.length;\n    // wrap around if at least 2 slides\n    let isWrapAround = this.options.wrapAround && len > 1;\n    let slideIndex = isWrapAround ? utils.modulo(index, len) : index;\n    let slide = this.slides[slideIndex];\n    if (!slide) return null;\n\n    // add distance for wrap-around slides\n    let wrap = isWrapAround ? this.slideableWidth * Math.floor(index / len) : 0;\n    return x - (slide.target + wrap);\n  };\n  proto.dragEndBoostSelect = function () {\n    // do not boost if no previousDragX or dragMoveTime\n    if (this.previousDragX === undefined || !this.dragMoveTime ||\n    // or if drag was held for 100 ms\n    new Date() - this.dragMoveTime > 100) {\n      return 0;\n    }\n    let distance = this.getSlideDistance(-this.dragX, this.selectedIndex);\n    let delta = this.previousDragX - this.dragX;\n    if (distance > 0 && delta > 0) {\n      // boost to next if moving towards the right, and positive velocity\n      return 1;\n    } else if (distance < 0 && delta < 0) {\n      // boost to previous if moving towards the left, and negative velocity\n      return -1;\n    }\n    return 0;\n  };\n\n  // ----- scroll ----- //\n\n  proto.onscroll = function () {\n    let scroll = getScrollPosition();\n    let scrollMoveX = this.pointerDownScroll.x - scroll.x;\n    let scrollMoveY = this.pointerDownScroll.y - scroll.y;\n    // cancel click/tap if scroll is too much\n    if (Math.abs(scrollMoveX) > 3 || Math.abs(scrollMoveY) > 3) {\n      this.pointerDone();\n    }\n  };\n\n  // ----- utils ----- //\n\n  function getScrollPosition() {\n    return {\n      x: window.pageXOffset,\n      y: window.pageYOffset\n    };\n  }\n\n  // -----  ----- //\n\n  return Flickity;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}