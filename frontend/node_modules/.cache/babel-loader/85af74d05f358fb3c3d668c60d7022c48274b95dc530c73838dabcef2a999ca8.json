{"ast":null,"code":"/*!\n * imagesLoaded v5.0.0\n * JavaScript is all like \"You images are done yet or what?\"\n * MIT License\n */\n\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('ev-emitter'));\n  } else {\n    // browser global\n    window.imagesLoaded = factory(window, window.EvEmitter);\n  }\n})(typeof window !== 'undefined' ? window : this, function factory(window, EvEmitter) {\n  let $ = window.jQuery;\n  let console = window.console;\n\n  // -------------------------- helpers -------------------------- //\n\n  // turn element or nodeList into an array\n  function makeArray(obj) {\n    // use object if already an array\n    if (Array.isArray(obj)) return obj;\n    let isArrayLike = typeof obj == 'object' && typeof obj.length == 'number';\n    // convert nodeList to array\n    if (isArrayLike) return [...obj];\n\n    // array of single index\n    return [obj];\n  }\n\n  // -------------------------- imagesLoaded -------------------------- //\n\n  /**\n   * @param {[Array, Element, NodeList, String]} elem\n   * @param {[Object, Function]} options - if function, use as callback\n   * @param {Function} onAlways - callback function\n   * @returns {ImagesLoaded}\n   */\n  function ImagesLoaded(elem, options, onAlways) {\n    // coerce ImagesLoaded() without new, to be new ImagesLoaded()\n    if (!(this instanceof ImagesLoaded)) {\n      return new ImagesLoaded(elem, options, onAlways);\n    }\n    // use elem as selector string\n    let queryElem = elem;\n    if (typeof elem == 'string') {\n      queryElem = document.querySelectorAll(elem);\n    }\n    // bail if bad element\n    if (!queryElem) {\n      console.error(`Bad element for imagesLoaded ${queryElem || elem}`);\n      return;\n    }\n    this.elements = makeArray(queryElem);\n    this.options = {};\n    // shift arguments if no options set\n    if (typeof options == 'function') {\n      onAlways = options;\n    } else {\n      Object.assign(this.options, options);\n    }\n    if (onAlways) this.on('always', onAlways);\n    this.getImages();\n    // add jQuery Deferred object\n    if ($) this.jqDeferred = new $.Deferred();\n\n    // HACK check async to allow time to bind listeners\n    setTimeout(this.check.bind(this));\n  }\n  ImagesLoaded.prototype = Object.create(EvEmitter.prototype);\n  ImagesLoaded.prototype.getImages = function () {\n    this.images = [];\n\n    // filter & find items if we have an item selector\n    this.elements.forEach(this.addElementImages, this);\n  };\n  const elementNodeTypes = [1, 9, 11];\n\n  /**\n   * @param {Node} elem\n   */\n  ImagesLoaded.prototype.addElementImages = function (elem) {\n    // filter siblings\n    if (elem.nodeName === 'IMG') {\n      this.addImage(elem);\n    }\n    // get background image on element\n    if (this.options.background === true) {\n      this.addElementBackgroundImages(elem);\n    }\n\n    // find children\n    // no non-element nodes, #143\n    let {\n      nodeType\n    } = elem;\n    if (!nodeType || !elementNodeTypes.includes(nodeType)) return;\n    let childImgs = elem.querySelectorAll('img');\n    // concat childElems to filterFound array\n    for (let img of childImgs) {\n      this.addImage(img);\n    }\n\n    // get child background images\n    if (typeof this.options.background == 'string') {\n      let children = elem.querySelectorAll(this.options.background);\n      for (let child of children) {\n        this.addElementBackgroundImages(child);\n      }\n    }\n  };\n  const reURL = /url\\((['\"])?(.*?)\\1\\)/gi;\n  ImagesLoaded.prototype.addElementBackgroundImages = function (elem) {\n    let style = getComputedStyle(elem);\n    // Firefox returns null if in a hidden iframe https://bugzil.la/548397\n    if (!style) return;\n\n    // get url inside url(\"...\")\n    let matches = reURL.exec(style.backgroundImage);\n    while (matches !== null) {\n      let url = matches && matches[2];\n      if (url) {\n        this.addBackground(url, elem);\n      }\n      matches = reURL.exec(style.backgroundImage);\n    }\n  };\n\n  /**\n   * @param {Image} img\n   */\n  ImagesLoaded.prototype.addImage = function (img) {\n    let loadingImage = new LoadingImage(img);\n    this.images.push(loadingImage);\n  };\n  ImagesLoaded.prototype.addBackground = function (url, elem) {\n    let background = new Background(url, elem);\n    this.images.push(background);\n  };\n  ImagesLoaded.prototype.check = function () {\n    this.progressedCount = 0;\n    this.hasAnyBroken = false;\n    // complete if no images\n    if (!this.images.length) {\n      this.complete();\n      return;\n    }\n\n    /* eslint-disable-next-line func-style */\n    let onProgress = (image, elem, message) => {\n      // HACK - Chrome triggers event before object properties have changed. #83\n      setTimeout(() => {\n        this.progress(image, elem, message);\n      });\n    };\n    this.images.forEach(function (loadingImage) {\n      loadingImage.once('progress', onProgress);\n      loadingImage.check();\n    });\n  };\n  ImagesLoaded.prototype.progress = function (image, elem, message) {\n    this.progressedCount++;\n    this.hasAnyBroken = this.hasAnyBroken || !image.isLoaded;\n    // progress event\n    this.emitEvent('progress', [this, image, elem]);\n    if (this.jqDeferred && this.jqDeferred.notify) {\n      this.jqDeferred.notify(this, image);\n    }\n    // check if completed\n    if (this.progressedCount === this.images.length) {\n      this.complete();\n    }\n    if (this.options.debug && console) {\n      console.log(`progress: ${message}`, image, elem);\n    }\n  };\n  ImagesLoaded.prototype.complete = function () {\n    let eventName = this.hasAnyBroken ? 'fail' : 'done';\n    this.isComplete = true;\n    this.emitEvent(eventName, [this]);\n    this.emitEvent('always', [this]);\n    if (this.jqDeferred) {\n      let jqMethod = this.hasAnyBroken ? 'reject' : 'resolve';\n      this.jqDeferred[jqMethod](this);\n    }\n  };\n\n  // --------------------------  -------------------------- //\n\n  function LoadingImage(img) {\n    this.img = img;\n  }\n  LoadingImage.prototype = Object.create(EvEmitter.prototype);\n  LoadingImage.prototype.check = function () {\n    // If complete is true and browser supports natural sizes,\n    // try to check for image status manually.\n    let isComplete = this.getIsImageComplete();\n    if (isComplete) {\n      // report based on naturalWidth\n      this.confirm(this.img.naturalWidth !== 0, 'naturalWidth');\n      return;\n    }\n\n    // If none of the checks above matched, simulate loading on detached element.\n    this.proxyImage = new Image();\n    // add crossOrigin attribute. #204\n    if (this.img.crossOrigin) {\n      this.proxyImage.crossOrigin = this.img.crossOrigin;\n    }\n    this.proxyImage.addEventListener('load', this);\n    this.proxyImage.addEventListener('error', this);\n    // bind to image as well for Firefox. #191\n    this.img.addEventListener('load', this);\n    this.img.addEventListener('error', this);\n    this.proxyImage.src = this.img.currentSrc || this.img.src;\n  };\n  LoadingImage.prototype.getIsImageComplete = function () {\n    // check for non-zero, non-undefined naturalWidth\n    // fixes Safari+InfiniteScroll+Masonry bug infinite-scroll#671\n    return this.img.complete && this.img.naturalWidth;\n  };\n  LoadingImage.prototype.confirm = function (isLoaded, message) {\n    this.isLoaded = isLoaded;\n    let {\n      parentNode\n    } = this.img;\n    // emit progress with parent <picture> or self <img>\n    let elem = parentNode.nodeName === 'PICTURE' ? parentNode : this.img;\n    this.emitEvent('progress', [this, elem, message]);\n  };\n\n  // ----- events ----- //\n\n  // trigger specified handler for event type\n  LoadingImage.prototype.handleEvent = function (event) {\n    let method = 'on' + event.type;\n    if (this[method]) {\n      this[method](event);\n    }\n  };\n  LoadingImage.prototype.onload = function () {\n    this.confirm(true, 'onload');\n    this.unbindEvents();\n  };\n  LoadingImage.prototype.onerror = function () {\n    this.confirm(false, 'onerror');\n    this.unbindEvents();\n  };\n  LoadingImage.prototype.unbindEvents = function () {\n    this.proxyImage.removeEventListener('load', this);\n    this.proxyImage.removeEventListener('error', this);\n    this.img.removeEventListener('load', this);\n    this.img.removeEventListener('error', this);\n  };\n\n  // -------------------------- Background -------------------------- //\n\n  function Background(url, element) {\n    this.url = url;\n    this.element = element;\n    this.img = new Image();\n  }\n\n  // inherit LoadingImage prototype\n  Background.prototype = Object.create(LoadingImage.prototype);\n  Background.prototype.check = function () {\n    this.img.addEventListener('load', this);\n    this.img.addEventListener('error', this);\n    this.img.src = this.url;\n    // check if image is already complete\n    let isComplete = this.getIsImageComplete();\n    if (isComplete) {\n      this.confirm(this.img.naturalWidth !== 0, 'naturalWidth');\n      this.unbindEvents();\n    }\n  };\n  Background.prototype.unbindEvents = function () {\n    this.img.removeEventListener('load', this);\n    this.img.removeEventListener('error', this);\n  };\n  Background.prototype.confirm = function (isLoaded, message) {\n    this.isLoaded = isLoaded;\n    this.emitEvent('progress', [this, this.element, message]);\n  };\n\n  // -------------------------- jQuery -------------------------- //\n\n  ImagesLoaded.makeJQueryPlugin = function (jQuery) {\n    jQuery = jQuery || window.jQuery;\n    if (!jQuery) return;\n\n    // set local variable\n    $ = jQuery;\n    // $().imagesLoaded()\n    $.fn.imagesLoaded = function (options, onAlways) {\n      let instance = new ImagesLoaded(this, options, onAlways);\n      return instance.jqDeferred.promise($(this));\n    };\n  };\n  // try making plugin\n  ImagesLoaded.makeJQueryPlugin();\n\n  // --------------------------  -------------------------- //\n\n  return ImagesLoaded;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}