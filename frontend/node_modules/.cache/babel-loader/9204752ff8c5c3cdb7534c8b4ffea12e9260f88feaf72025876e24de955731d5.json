{"ast":null,"code":"// animate\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(require('fizzy-ui-utils'));\n  } else {\n    // browser global\n    window.Flickity = window.Flickity || {};\n    window.Flickity.animatePrototype = factory(window.fizzyUIUtils);\n  }\n})(typeof window != 'undefined' ? window : this, function factory(utils) {\n  // -------------------------- animate -------------------------- //\n\n  let proto = {};\n  proto.startAnimation = function () {\n    if (this.isAnimating) return;\n    this.isAnimating = true;\n    this.restingFrames = 0;\n    this.animate();\n  };\n  proto.animate = function () {\n    this.applyDragForce();\n    this.applySelectedAttraction();\n    let previousX = this.x;\n    this.integratePhysics();\n    this.positionSlider();\n    this.settle(previousX);\n    // animate next frame\n    if (this.isAnimating) requestAnimationFrame(() => this.animate());\n  };\n  proto.positionSlider = function () {\n    let x = this.x;\n    // wrap position around\n    if (this.isWrapping) {\n      x = utils.modulo(x, this.slideableWidth) - this.slideableWidth;\n      this.shiftWrapCells(x);\n    }\n    this.setTranslateX(x, this.isAnimating);\n    this.dispatchScrollEvent();\n  };\n  proto.setTranslateX = function (x, is3d) {\n    x += this.cursorPosition;\n    // reverse if right-to-left and using transform\n    if (this.options.rightToLeft) x = -x;\n    let translateX = this.getPositionValue(x);\n    // use 3D transforms for hardware acceleration on iOS\n    // but use 2D when settled, for better font-rendering\n    this.slider.style.transform = is3d ? `translate3d(${translateX},0,0)` : `translateX(${translateX})`;\n  };\n  proto.dispatchScrollEvent = function () {\n    let firstSlide = this.slides[0];\n    if (!firstSlide) return;\n    let positionX = -this.x - firstSlide.target;\n    let progress = positionX / this.slidesWidth;\n    this.dispatchEvent('scroll', null, [progress, positionX]);\n  };\n  proto.positionSliderAtSelected = function () {\n    if (!this.cells.length) return;\n    this.x = -this.selectedSlide.target;\n    this.velocity = 0; // stop wobble\n    this.positionSlider();\n  };\n  proto.getPositionValue = function (position) {\n    if (this.options.percentPosition) {\n      // percent position, round to 2 digits, like 12.34%\n      return Math.round(position / this.size.innerWidth * 10000) * 0.01 + '%';\n    } else {\n      // pixel positioning\n      return Math.round(position) + 'px';\n    }\n  };\n  proto.settle = function (previousX) {\n    // keep track of frames where x hasn't moved\n    let isResting = !this.isPointerDown && Math.round(this.x * 100) === Math.round(previousX * 100);\n    if (isResting) this.restingFrames++;\n    // stop animating if resting for 3 or more frames\n    if (this.restingFrames > 2) {\n      this.isAnimating = false;\n      delete this.isFreeScrolling;\n      // render position with translateX when settled\n      this.positionSlider();\n      this.dispatchEvent('settle', null, [this.selectedIndex]);\n    }\n  };\n  proto.shiftWrapCells = function (x) {\n    // shift before cells\n    let beforeGap = this.cursorPosition + x;\n    this._shiftCells(this.beforeShiftCells, beforeGap, -1);\n    // shift after cells\n    let afterGap = this.size.innerWidth - (x + this.slideableWidth + this.cursorPosition);\n    this._shiftCells(this.afterShiftCells, afterGap, 1);\n  };\n  proto._shiftCells = function (cells, gap, shift) {\n    cells.forEach(cell => {\n      let cellShift = gap > 0 ? shift : 0;\n      this._wrapShiftCell(cell, cellShift);\n      gap -= cell.size.outerWidth;\n    });\n  };\n  proto._unshiftCells = function (cells) {\n    if (!cells || !cells.length) return;\n    cells.forEach(cell => this._wrapShiftCell(cell, 0));\n  };\n\n  // @param {Integer} shift - 0, 1, or -1\n  proto._wrapShiftCell = function (cell, shift) {\n    this._renderCellPosition(cell, cell.x + this.slideableWidth * shift);\n  };\n\n  // -------------------------- physics -------------------------- //\n\n  proto.integratePhysics = function () {\n    this.x += this.velocity;\n    this.velocity *= this.getFrictionFactor();\n  };\n  proto.applyForce = function (force) {\n    this.velocity += force;\n  };\n  proto.getFrictionFactor = function () {\n    return 1 - this.options[this.isFreeScrolling ? 'freeScrollFriction' : 'friction'];\n  };\n  proto.getRestingPosition = function () {\n    // my thanks to Steven Wittens, who simplified this math greatly\n    return this.x + this.velocity / (1 - this.getFrictionFactor());\n  };\n  proto.applyDragForce = function () {\n    if (!this.isDraggable || !this.isPointerDown) return;\n\n    // change the position to drag position by applying force\n    let dragVelocity = this.dragX - this.x;\n    let dragForce = dragVelocity - this.velocity;\n    this.applyForce(dragForce);\n  };\n  proto.applySelectedAttraction = function () {\n    // do not attract if pointer down or no slides\n    let dragDown = this.isDraggable && this.isPointerDown;\n    if (dragDown || this.isFreeScrolling || !this.slides.length) return;\n    let distance = this.selectedSlide.target * -1 - this.x;\n    let force = distance * this.options.selectedAttraction;\n    this.applyForce(force);\n  };\n  return proto;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}