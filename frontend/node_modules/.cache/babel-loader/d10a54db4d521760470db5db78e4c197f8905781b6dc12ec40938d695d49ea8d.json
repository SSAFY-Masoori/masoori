{"ast":null,"code":"// Flickity main\n/* eslint-disable max-params */\n(function (window, factory) {\n  // universal module definition\n  if (typeof module == 'object' && module.exports) {\n    // CommonJS\n    module.exports = factory(window, require('ev-emitter'), require('get-size'), require('fizzy-ui-utils'), require('./cell'), require('./slide'), require('./animate'));\n  } else {\n    // browser global\n    let _Flickity = window.Flickity;\n    window.Flickity = factory(window, window.EvEmitter, window.getSize, window.fizzyUIUtils, _Flickity.Cell, _Flickity.Slide, _Flickity.animatePrototype);\n  }\n})(typeof window != 'undefined' ? window : this, function factory(window, EvEmitter, getSize, utils, Cell, Slide, animatePrototype) {\n  /* eslint-enable max-params */\n\n  // vars\n  const {\n    getComputedStyle,\n    console\n  } = window;\n  let {\n    jQuery\n  } = window;\n\n  // -------------------------- Flickity -------------------------- //\n\n  // globally unique identifiers\n  let GUID = 0;\n  // internal store of all Flickity intances\n  let instances = {};\n  function Flickity(element, options) {\n    let queryElement = utils.getQueryElement(element);\n    if (!queryElement) {\n      if (console) console.error(`Bad element for Flickity: ${queryElement || element}`);\n      return;\n    }\n    this.element = queryElement;\n    // do not initialize twice on same element\n    if (this.element.flickityGUID) {\n      let instance = instances[this.element.flickityGUID];\n      if (instance) instance.option(options);\n      return instance;\n    }\n\n    // add jQuery\n    if (jQuery) {\n      this.$element = jQuery(this.element);\n    }\n    // options\n    this.options = {\n      ...this.constructor.defaults\n    };\n    this.option(options);\n\n    // kick things off\n    this._create();\n  }\n  Flickity.defaults = {\n    accessibility: true,\n    // adaptiveHeight: false,\n    cellAlign: 'center',\n    // cellSelector: undefined,\n    // contain: false,\n    freeScrollFriction: 0.075,\n    // friction when free-scrolling\n    friction: 0.28,\n    // friction when selecting\n    namespaceJQueryEvents: true,\n    // initialIndex: 0,\n    percentPosition: true,\n    resize: true,\n    selectedAttraction: 0.025,\n    setGallerySize: true\n    // watchCSS: false,\n    // wrapAround: false\n  };\n\n  // hash of methods triggered on _create()\n  Flickity.create = {};\n  let proto = Flickity.prototype;\n  // inherit EventEmitter\n  Object.assign(proto, EvEmitter.prototype);\n  proto._create = function () {\n    let {\n      resize,\n      watchCSS,\n      rightToLeft\n    } = this.options;\n    // add id for Flickity.data\n    let id = this.guid = ++GUID;\n    this.element.flickityGUID = id; // expando\n    instances[id] = this; // associate via id\n    // initial properties\n    this.selectedIndex = 0;\n    // how many frames slider has been in same position\n    this.restingFrames = 0;\n    // initial physics properties\n    this.x = 0;\n    this.velocity = 0;\n    this.beginMargin = rightToLeft ? 'marginRight' : 'marginLeft';\n    this.endMargin = rightToLeft ? 'marginLeft' : 'marginRight';\n    // create viewport & slider\n    this.viewport = document.createElement('div');\n    this.viewport.className = 'flickity-viewport';\n    this._createSlider();\n    // used for keyboard navigation\n    this.focusableElems = [this.element];\n    if (resize || watchCSS) {\n      window.addEventListener('resize', this);\n    }\n\n    // add listeners from on option\n    for (let eventName in this.options.on) {\n      let listener = this.options.on[eventName];\n      this.on(eventName, listener);\n    }\n    for (let method in Flickity.create) {\n      Flickity.create[method].call(this);\n    }\n    if (watchCSS) {\n      this.watchCSS();\n    } else {\n      this.activate();\n    }\n  };\n\n  /**\n   * set options\n   * @param {Object} opts - options to extend\n   */\n  proto.option = function (opts) {\n    Object.assign(this.options, opts);\n  };\n  proto.activate = function () {\n    if (this.isActive) return;\n    this.isActive = true;\n    this.element.classList.add('flickity-enabled');\n    if (this.options.rightToLeft) {\n      this.element.classList.add('flickity-rtl');\n    }\n    this.getSize();\n    // move initial cell elements so they can be loaded as cells\n    let cellElems = this._filterFindCellElements(this.element.children);\n    this.slider.append(...cellElems);\n    this.viewport.append(this.slider);\n    this.element.append(this.viewport);\n    // get cells from children\n    this.reloadCells();\n    if (this.options.accessibility) {\n      // allow element to focusable\n      this.element.tabIndex = 0;\n      // listen for key presses\n      this.element.addEventListener('keydown', this);\n    }\n    this.emitEvent('activate');\n    this.selectInitialIndex();\n    // flag for initial activation, for using initialIndex\n    this.isInitActivated = true;\n    // ready event. #493\n    this.dispatchEvent('ready');\n  };\n\n  // slider positions the cells\n  proto._createSlider = function () {\n    // slider element does all the positioning\n    let slider = document.createElement('div');\n    slider.className = 'flickity-slider';\n    this.slider = slider;\n  };\n  proto._filterFindCellElements = function (elems) {\n    return utils.filterFindElements(elems, this.options.cellSelector);\n  };\n\n  // goes through all children\n  proto.reloadCells = function () {\n    // collection of item elements\n    this.cells = this._makeCells(this.slider.children);\n    this.positionCells();\n    this._updateWrapShiftCells();\n    this.setGallerySize();\n  };\n\n  /**\n   * turn elements into Flickity.Cells\n   * @param {[Array, NodeList, HTMLElement]} elems - elements to make into cells\n   * @returns {Array} items - collection of new Flickity Cells\n   */\n  proto._makeCells = function (elems) {\n    let cellElems = this._filterFindCellElements(elems);\n\n    // create new Cells for collection\n    return cellElems.map(cellElem => new Cell(cellElem));\n  };\n  proto.getLastCell = function () {\n    return this.cells[this.cells.length - 1];\n  };\n  proto.getLastSlide = function () {\n    return this.slides[this.slides.length - 1];\n  };\n\n  // positions all cells\n  proto.positionCells = function () {\n    // size all cells\n    this._sizeCells(this.cells);\n    // position all cells\n    this._positionCells(0);\n  };\n\n  /**\n   * position certain cells\n   * @param {Integer} index - which cell to start with\n   */\n  proto._positionCells = function (index) {\n    index = index || 0;\n    // also measure maxCellHeight\n    // start 0 if positioning all cells\n    this.maxCellHeight = index ? this.maxCellHeight || 0 : 0;\n    let cellX = 0;\n    // get cellX\n    if (index > 0) {\n      let startCell = this.cells[index - 1];\n      cellX = startCell.x + startCell.size.outerWidth;\n    }\n    this.cells.slice(index).forEach(cell => {\n      cell.x = cellX;\n      this._renderCellPosition(cell, cellX);\n      cellX += cell.size.outerWidth;\n      this.maxCellHeight = Math.max(cell.size.outerHeight, this.maxCellHeight);\n    });\n    // keep track of cellX for wrap-around\n    this.slideableWidth = cellX;\n    // slides\n    this.updateSlides();\n    // contain slides target\n    this._containSlides();\n    // update slidesWidth\n    this.slidesWidth = this.cells.length ? this.getLastSlide().target - this.slides[0].target : 0;\n  };\n  proto._renderCellPosition = function (cell, x) {\n    // render position of cell with in slider\n    let sideOffset = this.options.rightToLeft ? -1 : 1;\n    let renderX = x * sideOffset;\n    if (this.options.percentPosition) renderX *= this.size.innerWidth / cell.size.width;\n    let positionValue = this.getPositionValue(renderX);\n    cell.element.style.transform = `translateX( ${positionValue} )`;\n  };\n\n  /**\n   * cell.getSize() on multiple cells\n   * @param {Array} cells - cells to size\n   */\n  proto._sizeCells = function (cells) {\n    cells.forEach(cell => cell.getSize());\n  };\n\n  // --------------------------  -------------------------- //\n\n  proto.updateSlides = function () {\n    this.slides = [];\n    if (!this.cells.length) return;\n    let {\n      beginMargin,\n      endMargin\n    } = this;\n    let slide = new Slide(beginMargin, endMargin, this.cellAlign);\n    this.slides.push(slide);\n    let canCellFit = this._getCanCellFit();\n    this.cells.forEach((cell, i) => {\n      // just add cell if first cell in slide\n      if (!slide.cells.length) {\n        slide.addCell(cell);\n        return;\n      }\n      let slideWidth = slide.outerWidth - slide.firstMargin + (cell.size.outerWidth - cell.size[endMargin]);\n      if (canCellFit(i, slideWidth)) {\n        slide.addCell(cell);\n      } else {\n        // doesn't fit, new slide\n        slide.updateTarget();\n        slide = new Slide(beginMargin, endMargin, this.cellAlign);\n        this.slides.push(slide);\n        slide.addCell(cell);\n      }\n    });\n    // last slide\n    slide.updateTarget();\n    // update .selectedSlide\n    this.updateSelectedSlide();\n  };\n  proto._getCanCellFit = function () {\n    let {\n      groupCells\n    } = this.options;\n    if (!groupCells) return () => false;\n    if (typeof groupCells == 'number') {\n      // group by number. 3 -> [0,1,2], [3,4,5], ...\n      let number = parseInt(groupCells, 10);\n      return i => i % number !== 0;\n    }\n    // default, group by width of slide\n    let percent = 1;\n    // parse '75%\n    let percentMatch = typeof groupCells == 'string' && groupCells.match(/^(\\d+)%$/);\n    if (percentMatch) percent = parseInt(percentMatch[1], 10) / 100;\n    let groupWidth = (this.size.innerWidth + 1) * percent;\n    return (i, slideWidth) => slideWidth <= groupWidth;\n  };\n\n  // alias _init for jQuery plugin .flickity()\n  proto._init = proto.reposition = function () {\n    this.positionCells();\n    this.positionSliderAtSelected();\n  };\n  proto.getSize = function () {\n    this.size = getSize(this.element);\n    this.setCellAlign();\n    this.cursorPosition = this.size.innerWidth * this.cellAlign;\n  };\n  let cellAlignShorthands = {\n    left: 0,\n    center: 0.5,\n    right: 1\n  };\n  proto.setCellAlign = function () {\n    let {\n      cellAlign,\n      rightToLeft\n    } = this.options;\n    let shorthand = cellAlignShorthands[cellAlign];\n    this.cellAlign = shorthand !== undefined ? shorthand : cellAlign;\n    if (rightToLeft) this.cellAlign = 1 - this.cellAlign;\n  };\n  proto.setGallerySize = function () {\n    if (!this.options.setGallerySize) return;\n    let height = this.options.adaptiveHeight && this.selectedSlide ? this.selectedSlide.height : this.maxCellHeight;\n    this.viewport.style.height = `${height}px`;\n  };\n  proto._updateWrapShiftCells = function () {\n    // update isWrapping\n    this.isWrapping = this.getIsWrapping();\n    // only for wrap-around\n    if (!this.isWrapping) return;\n\n    // unshift previous cells\n    this._unshiftCells(this.beforeShiftCells);\n    this._unshiftCells(this.afterShiftCells);\n    // get before cells\n    // initial gap\n    let beforeGapX = this.cursorPosition;\n    let lastIndex = this.cells.length - 1;\n    this.beforeShiftCells = this._getGapCells(beforeGapX, lastIndex, -1);\n    // get after cells\n    // ending gap between last cell and end of gallery viewport\n    let afterGapX = this.size.innerWidth - this.cursorPosition;\n    // start cloning at first cell, working forwards\n    this.afterShiftCells = this._getGapCells(afterGapX, 0, 1);\n  };\n  proto.getIsWrapping = function () {\n    let {\n      wrapAround\n    } = this.options;\n    if (!wrapAround || this.slides.length < 2) return false;\n    if (wrapAround !== 'fill') return true;\n    // check that slides can fit\n\n    let gapWidth = this.slideableWidth - this.size.innerWidth;\n    if (gapWidth > this.size.innerWidth) return true; // gap * 2x big, all good\n    // check that content width - shifting cell is bigger than viewport width\n    for (let cell of this.cells) {\n      if (cell.size.outerWidth > gapWidth) return false;\n    }\n    return true;\n  };\n  proto._getGapCells = function (gapX, cellIndex, increment) {\n    // keep adding cells until the cover the initial gap\n    let cells = [];\n    while (gapX > 0) {\n      let cell = this.cells[cellIndex];\n      if (!cell) break;\n      cells.push(cell);\n      cellIndex += increment;\n      gapX -= cell.size.outerWidth;\n    }\n    return cells;\n  };\n\n  // ----- contain & wrap ----- //\n\n  // contain cell targets so no excess sliding\n  proto._containSlides = function () {\n    let isContaining = this.options.contain && !this.isWrapping && this.cells.length;\n    if (!isContaining) return;\n    let contentWidth = this.slideableWidth - this.getLastCell().size[this.endMargin];\n    // content is less than gallery size\n    let isContentSmaller = contentWidth < this.size.innerWidth;\n    if (isContentSmaller) {\n      // all cells fit inside gallery\n      this.slides.forEach(slide => {\n        slide.target = contentWidth * this.cellAlign;\n      });\n    } else {\n      // contain to bounds\n      let beginBound = this.cursorPosition + this.cells[0].size[this.beginMargin];\n      let endBound = contentWidth - this.size.innerWidth * (1 - this.cellAlign);\n      this.slides.forEach(slide => {\n        slide.target = Math.max(slide.target, beginBound);\n        slide.target = Math.min(slide.target, endBound);\n      });\n    }\n  };\n\n  // ----- events ----- //\n\n  /**\n   * emits events via eventEmitter and jQuery events\n   * @param {String} type - name of event\n   * @param {Event} event - original event\n   * @param {Array} args - extra arguments\n   */\n  proto.dispatchEvent = function (type, event, args) {\n    let emitArgs = event ? [event].concat(args) : args;\n    this.emitEvent(type, emitArgs);\n    if (jQuery && this.$element) {\n      // default trigger with type if no event\n      type += this.options.namespaceJQueryEvents ? '.flickity' : '';\n      let $event = type;\n      if (event) {\n        // create jQuery event\n        let jQEvent = new jQuery.Event(event);\n        jQEvent.type = type;\n        $event = jQEvent;\n      }\n      this.$element.trigger($event, args);\n    }\n  };\n  const unidraggerEvents = ['dragStart', 'dragMove', 'dragEnd', 'pointerDown', 'pointerMove', 'pointerEnd', 'staticClick'];\n  let _emitEvent = proto.emitEvent;\n  proto.emitEvent = function (eventName, args) {\n    if (eventName === 'staticClick') {\n      // add cellElem and cellIndex args to staticClick\n      let clickedCell = this.getParentCell(args[0].target);\n      let cellElem = clickedCell && clickedCell.element;\n      let cellIndex = clickedCell && this.cells.indexOf(clickedCell);\n      args = args.concat(cellElem, cellIndex);\n    }\n    // do regular thing\n    _emitEvent.call(this, eventName, args);\n    // duck-punch in jQuery events for Unidragger events\n    let isUnidraggerEvent = unidraggerEvents.includes(eventName);\n    if (!isUnidraggerEvent || !jQuery || !this.$element) return;\n    eventName += this.options.namespaceJQueryEvents ? '.flickity' : '';\n    let event = args.shift(0);\n    let jQEvent = new jQuery.Event(event);\n    jQEvent.type = eventName;\n    this.$element.trigger(jQEvent, args);\n  };\n\n  // -------------------------- select -------------------------- //\n\n  /**\n   * @param {Integer} index - index of the slide\n   * @param {Boolean} isWrap - will wrap-around to last/first if at the end\n   * @param {Boolean} isInstant - will immediately set position at selected cell\n   */\n  proto.select = function (index, isWrap, isInstant) {\n    if (!this.isActive) return;\n    index = parseInt(index, 10);\n    this._wrapSelect(index);\n    if (this.isWrapping || isWrap) {\n      index = utils.modulo(index, this.slides.length);\n    }\n    // bail if invalid index\n    if (!this.slides[index]) return;\n    let prevIndex = this.selectedIndex;\n    this.selectedIndex = index;\n    this.updateSelectedSlide();\n    if (isInstant) {\n      this.positionSliderAtSelected();\n    } else {\n      this.startAnimation();\n    }\n    if (this.options.adaptiveHeight) {\n      this.setGallerySize();\n    }\n    // events\n    this.dispatchEvent('select', null, [index]);\n    // change event if new index\n    if (index !== prevIndex) {\n      this.dispatchEvent('change', null, [index]);\n    }\n  };\n\n  // wraps position for wrapAround, to move to closest slide. #113\n  proto._wrapSelect = function (index) {\n    if (!this.isWrapping) return;\n    const {\n      selectedIndex,\n      slideableWidth,\n      slides: {\n        length\n      }\n    } = this;\n    // shift index for wrap, do not wrap dragSelect\n    if (!this.isDragSelect) {\n      let wrapIndex = utils.modulo(index, length);\n      // go to shortest\n      let delta = Math.abs(wrapIndex - selectedIndex);\n      let backWrapDelta = Math.abs(wrapIndex + length - selectedIndex);\n      let forewardWrapDelta = Math.abs(wrapIndex - length - selectedIndex);\n      if (backWrapDelta < delta) {\n        index += length;\n      } else if (forewardWrapDelta < delta) {\n        index -= length;\n      }\n    }\n\n    // wrap position so slider is within normal area\n    if (index < 0) {\n      this.x -= slideableWidth;\n    } else if (index >= length) {\n      this.x += slideableWidth;\n    }\n  };\n  proto.previous = function (isWrap, isInstant) {\n    this.select(this.selectedIndex - 1, isWrap, isInstant);\n  };\n  proto.next = function (isWrap, isInstant) {\n    this.select(this.selectedIndex + 1, isWrap, isInstant);\n  };\n  proto.updateSelectedSlide = function () {\n    let slide = this.slides[this.selectedIndex];\n    // selectedIndex could be outside of slides, if triggered before resize()\n    if (!slide) return;\n\n    // unselect previous selected slide\n    this.unselectSelectedSlide();\n    // update new selected slide\n    this.selectedSlide = slide;\n    slide.select();\n    this.selectedCells = slide.cells;\n    this.selectedElements = slide.getCellElements();\n    // HACK: selectedCell & selectedElement is first cell in slide, backwards compatibility\n    this.selectedCell = slide.cells[0];\n    this.selectedElement = this.selectedElements[0];\n  };\n  proto.unselectSelectedSlide = function () {\n    if (this.selectedSlide) this.selectedSlide.unselect();\n  };\n  proto.selectInitialIndex = function () {\n    let initialIndex = this.options.initialIndex;\n    // already activated, select previous selectedIndex\n    if (this.isInitActivated) {\n      this.select(this.selectedIndex, false, true);\n      return;\n    }\n    // select with selector string\n    if (initialIndex && typeof initialIndex == 'string') {\n      let cell = this.queryCell(initialIndex);\n      if (cell) {\n        this.selectCell(initialIndex, false, true);\n        return;\n      }\n    }\n    let index = 0;\n    // select with number\n    if (initialIndex && this.slides[initialIndex]) {\n      index = initialIndex;\n    }\n    // select instantly\n    this.select(index, false, true);\n  };\n\n  /**\n   * select slide from number or cell element\n   * @param {[Element, Number]} value - zero-based index or element to select\n   * @param {Boolean} isWrap - enables wrapping around for extra index\n   * @param {Boolean} isInstant - disables slide animation\n   */\n  proto.selectCell = function (value, isWrap, isInstant) {\n    // get cell\n    let cell = this.queryCell(value);\n    if (!cell) return;\n    let index = this.getCellSlideIndex(cell);\n    this.select(index, isWrap, isInstant);\n  };\n  proto.getCellSlideIndex = function (cell) {\n    // get index of slide that has cell\n    let cellSlide = this.slides.find(slide => slide.cells.includes(cell));\n    return this.slides.indexOf(cellSlide);\n  };\n\n  // -------------------------- get cells -------------------------- //\n\n  /**\n   * get Flickity.Cell, given an Element\n   * @param {Element} elem - matching cell element\n   * @returns {Flickity.Cell} cell - matching cell\n   */\n  proto.getCell = function (elem) {\n    // loop through cells to get the one that matches\n    for (let cell of this.cells) {\n      if (cell.element === elem) return cell;\n    }\n  };\n\n  /**\n   * get collection of Flickity.Cells, given Elements\n   * @param {[Element, Array, NodeList]} elems - multiple elements\n   * @returns {Array} cells - Flickity.Cells\n   */\n  proto.getCells = function (elems) {\n    elems = utils.makeArray(elems);\n    return elems.map(elem => this.getCell(elem)).filter(Boolean);\n  };\n\n  /**\n   * get cell elements\n   * @returns {Array} cellElems\n   */\n  proto.getCellElements = function () {\n    return this.cells.map(cell => cell.element);\n  };\n\n  /**\n   * get parent cell from an element\n   * @param {Element} elem - child element\n   * @returns {Flickit.Cell} cell - parent cell\n   */\n  proto.getParentCell = function (elem) {\n    // first check if elem is cell\n    let cell = this.getCell(elem);\n    if (cell) return cell;\n\n    // try to get parent cell elem\n    let closest = elem.closest('.flickity-slider > *');\n    return this.getCell(closest);\n  };\n\n  /**\n   * get cells adjacent to a slide\n   * @param {Integer} adjCount - number of adjacent slides\n   * @param {Integer} index - index of slide to start\n   * @returns {Array} cells - array of Flickity.Cells\n   */\n  proto.getAdjacentCellElements = function (adjCount, index) {\n    if (!adjCount) return this.selectedSlide.getCellElements();\n    index = index === undefined ? this.selectedIndex : index;\n    let len = this.slides.length;\n    if (1 + adjCount * 2 >= len) {\n      return this.getCellElements(); // get all\n    }\n\n    let cellElems = [];\n    for (let i = index - adjCount; i <= index + adjCount; i++) {\n      let slideIndex = this.isWrapping ? utils.modulo(i, len) : i;\n      let slide = this.slides[slideIndex];\n      if (slide) {\n        cellElems = cellElems.concat(slide.getCellElements());\n      }\n    }\n    return cellElems;\n  };\n\n  /**\n   * select slide from number or cell element\n   * @param {[Element, String, Number]} selector - element, selector string, or index\n   * @returns {Flickity.Cell} - matching cell\n   */\n  proto.queryCell = function (selector) {\n    if (typeof selector == 'number') {\n      // use number as index\n      return this.cells[selector];\n    }\n    // do not select invalid selectors from hash: #123, #/. #791\n    let isSelectorString = typeof selector == 'string' && !selector.match(/^[#.]?[\\d/]/);\n    if (isSelectorString) {\n      // use string as selector, get element\n      selector = this.element.querySelector(selector);\n    }\n    // get cell from element\n    return this.getCell(selector);\n  };\n\n  // -------------------------- events -------------------------- //\n\n  proto.uiChange = function () {\n    this.emitEvent('uiChange');\n  };\n\n  // ----- resize ----- //\n\n  proto.onresize = function () {\n    this.watchCSS();\n    this.resize();\n  };\n  utils.debounceMethod(Flickity, 'onresize', 150);\n  proto.resize = function () {\n    // #1177 disable resize behavior when animating or dragging for iOS 15\n    if (!this.isActive || this.isAnimating || this.isDragging) return;\n    this.getSize();\n    // wrap values\n    if (this.isWrapping) {\n      this.x = utils.modulo(this.x, this.slideableWidth);\n    }\n    this.positionCells();\n    this._updateWrapShiftCells();\n    this.setGallerySize();\n    this.emitEvent('resize');\n    // update selected index for group slides, instant\n    // TODO: position can be lost between groups of various numbers\n    let selectedElement = this.selectedElements && this.selectedElements[0];\n    this.selectCell(selectedElement, false, true);\n  };\n\n  // watches the :after property, activates/deactivates\n  proto.watchCSS = function () {\n    if (!this.options.watchCSS) return;\n    let afterContent = getComputedStyle(this.element, ':after').content;\n    // activate if :after { content: 'flickity' }\n    if (afterContent.includes('flickity')) {\n      this.activate();\n    } else {\n      this.deactivate();\n    }\n  };\n\n  // ----- keydown ----- //\n\n  // go previous/next if left/right keys pressed\n  proto.onkeydown = function (event) {\n    let {\n      activeElement\n    } = document;\n    let handler = Flickity.keyboardHandlers[event.key];\n    // only work if element is in focus\n    if (!this.options.accessibility || !activeElement || !handler) return;\n    let isFocused = this.focusableElems.some(elem => activeElement === elem);\n    if (isFocused) handler.call(this);\n  };\n  Flickity.keyboardHandlers = {\n    ArrowLeft: function () {\n      this.uiChange();\n      let leftMethod = this.options.rightToLeft ? 'next' : 'previous';\n      this[leftMethod]();\n    },\n    ArrowRight: function () {\n      this.uiChange();\n      let rightMethod = this.options.rightToLeft ? 'previous' : 'next';\n      this[rightMethod]();\n    }\n  };\n\n  // ----- focus ----- //\n\n  proto.focus = function () {\n    this.element.focus({\n      preventScroll: true\n    });\n  };\n\n  // -------------------------- destroy -------------------------- //\n\n  // deactivate all Flickity functionality, but keep stuff available\n  proto.deactivate = function () {\n    if (!this.isActive) return;\n    this.element.classList.remove('flickity-enabled');\n    this.element.classList.remove('flickity-rtl');\n    this.unselectSelectedSlide();\n    // destroy cells\n    this.cells.forEach(cell => cell.destroy());\n    this.viewport.remove();\n    // move child elements back into element\n    this.element.append(...this.slider.children);\n    if (this.options.accessibility) {\n      this.element.removeAttribute('tabIndex');\n      this.element.removeEventListener('keydown', this);\n    }\n    // set flags\n    this.isActive = false;\n    this.emitEvent('deactivate');\n  };\n  proto.destroy = function () {\n    this.deactivate();\n    window.removeEventListener('resize', this);\n    this.allOff();\n    this.emitEvent('destroy');\n    if (jQuery && this.$element) {\n      jQuery.removeData(this.element, 'flickity');\n    }\n    delete this.element.flickityGUID;\n    delete instances[this.guid];\n  };\n\n  // -------------------------- prototype -------------------------- //\n\n  Object.assign(proto, animatePrototype);\n\n  // -------------------------- extras -------------------------- //\n\n  /**\n   * get Flickity instance from element\n   * @param {[Element, String]} elem - element or selector string\n   * @returns {Flickity} - Flickity instance\n   */\n  Flickity.data = function (elem) {\n    elem = utils.getQueryElement(elem);\n    if (elem) return instances[elem.flickityGUID];\n  };\n  utils.htmlInit(Flickity, 'flickity');\n  let {\n    jQueryBridget\n  } = window;\n  if (jQuery && jQueryBridget) {\n    jQueryBridget('flickity', Flickity, jQuery);\n  }\n\n  // set internal jQuery, for Webpack + jQuery v3, #478\n  Flickity.setJQuery = function (jq) {\n    jQuery = jq;\n  };\n  Flickity.Cell = Cell;\n  Flickity.Slide = Slide;\n  return Flickity;\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}