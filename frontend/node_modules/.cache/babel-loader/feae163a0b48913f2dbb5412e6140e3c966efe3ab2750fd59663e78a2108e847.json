{"ast":null,"code":"!function (t, e) {\n  \"object\" == typeof exports && \"undefined\" != typeof module ? e(exports) : \"function\" == typeof define && define.amd ? define([\"exports\"], e) : e((t = t || self).St = {});\n}(this, function (t) {\n  \"use strict\";\n\n  class e {\n    constructor(t, e) {\n      this.state = {\n        angle: 0,\n        area: [],\n        position: {\n          x: 0,\n          y: 0\n        },\n        hardAngle: 0,\n        hardDrawingAngle: 0\n      }, this.createdDensity = e, this.nowDrawingDensity = this.createdDensity, this.render = t;\n    }\n    setDensity(t) {\n      this.createdDensity = t, this.nowDrawingDensity = t;\n    }\n    setDrawingDensity(t) {\n      this.nowDrawingDensity = t;\n    }\n    setPosition(t) {\n      this.state.position = t;\n    }\n    setAngle(t) {\n      this.state.angle = t;\n    }\n    setArea(t) {\n      this.state.area = t;\n    }\n    setHardDrawingAngle(t) {\n      this.state.hardDrawingAngle = t;\n    }\n    setHardAngle(t) {\n      this.state.hardAngle = t, this.state.hardDrawingAngle = t;\n    }\n    setOrientation(t) {\n      this.orientation = t;\n    }\n    getDrawingDensity() {\n      return this.nowDrawingDensity;\n    }\n    getDensity() {\n      return this.createdDensity;\n    }\n    getHardAngle() {\n      return this.state.hardAngle;\n    }\n  }\n  class i extends e {\n    constructor(t, e, i) {\n      super(t, i), this.image = null, this.isLoad = !1, this.loadingAngle = 0, this.image = new Image(), this.image.src = e;\n    }\n    draw(t) {\n      const e = this.render.getContext(),\n        i = this.render.convertToGlobal(this.state.position),\n        s = this.render.getRect().pageWidth,\n        n = this.render.getRect().height;\n      e.save(), e.translate(i.x, i.y), e.beginPath();\n      for (let t of this.state.area) null !== t && (t = this.render.convertToGlobal(t), e.lineTo(t.x - i.x, t.y - i.y));\n      e.rotate(this.state.angle), e.clip(), this.isLoad ? e.drawImage(this.image, 0, 0, s, n) : this.drawLoader(e, {\n        x: 0,\n        y: 0\n      }, s, n), e.restore();\n    }\n    simpleDraw(t) {\n      const e = this.render.getRect(),\n        i = this.render.getContext(),\n        s = e.pageWidth,\n        n = e.height,\n        h = 1 === t ? e.left + e.pageWidth : e.left,\n        r = e.top;\n      this.isLoad ? i.drawImage(this.image, h, r, s, n) : this.drawLoader(i, {\n        x: h,\n        y: r\n      }, s, n);\n    }\n    drawLoader(t, e, i, s) {\n      t.beginPath(), t.strokeStyle = \"rgb(200, 200, 200)\", t.fillStyle = \"rgb(255, 255, 255)\", t.lineWidth = 1, t.rect(e.x + 1, e.y + 1, i - 1, s - 1), t.stroke(), t.fill();\n      const n = {\n        x: e.x + i / 2,\n        y: e.y + s / 2\n      };\n      t.beginPath(), t.lineWidth = 10, t.arc(n.x, n.y, 20, this.loadingAngle, 3 * Math.PI / 2 + this.loadingAngle), t.stroke(), t.closePath(), this.loadingAngle += .07, this.loadingAngle >= 2 * Math.PI && (this.loadingAngle = 0);\n    }\n    load() {\n      this.isLoad || (this.image.onload = () => {\n        this.isLoad = !0;\n      });\n    }\n    newTemporaryCopy() {\n      return this;\n    }\n    getTemporaryCopy() {\n      return this;\n    }\n    hideTemporaryCopy() {}\n  }\n  class s {\n    constructor(t, e) {\n      this.pages = [], this.currentPageIndex = 0, this.currentSpreadIndex = 0, this.landscapeSpread = [], this.portraitSpread = [], this.render = e, this.app = t, this.currentPageIndex = 0, this.isShowCover = this.app.getSettings().showCover;\n    }\n    destroy() {\n      this.pages = [];\n    }\n    createSpread() {\n      this.landscapeSpread = [], this.portraitSpread = [];\n      for (let t = 0; t < this.pages.length; t++) this.portraitSpread.push([t]);\n      let t = 0;\n      this.isShowCover && (this.pages[0].setDensity(\"hard\"), this.landscapeSpread.push([t]), t++);\n      for (let e = t; e < this.pages.length; e += 2) e < this.pages.length - 1 ? this.landscapeSpread.push([e, e + 1]) : (this.landscapeSpread.push([e]), this.pages[e].setDensity(\"hard\"));\n    }\n    getSpread() {\n      return \"landscape\" === this.render.getOrientation() ? this.landscapeSpread : this.portraitSpread;\n    }\n    getSpreadIndexByPage(t) {\n      const e = this.getSpread();\n      for (let i = 0; i < e.length; i++) if (t === e[i][0] || t === e[i][1]) return i;\n      return null;\n    }\n    getPageCount() {\n      return this.pages.length;\n    }\n    getPages() {\n      return this.pages;\n    }\n    getPage(t) {\n      if (t >= 0 && t < this.pages.length) return this.pages[t];\n      throw new Error(\"Invalid page number\");\n    }\n    nextBy(t) {\n      const e = this.pages.indexOf(t);\n      return e < this.pages.length - 1 ? this.pages[e + 1] : null;\n    }\n    prevBy(t) {\n      const e = this.pages.indexOf(t);\n      return e > 0 ? this.pages[e - 1] : null;\n    }\n    getFlippingPage(t) {\n      const e = this.currentSpreadIndex;\n      if (\"portrait\" === this.render.getOrientation()) return 0 === t ? this.pages[e].newTemporaryCopy() : this.pages[e - 1];\n      {\n        const i = 0 === t ? this.getSpread()[e + 1] : this.getSpread()[e - 1];\n        return 1 === i.length || 0 === t ? this.pages[i[0]] : this.pages[i[1]];\n      }\n    }\n    getBottomPage(t) {\n      const e = this.currentSpreadIndex;\n      if (\"portrait\" === this.render.getOrientation()) return 0 === t ? this.pages[e + 1] : this.pages[e - 1];\n      {\n        const i = 0 === t ? this.getSpread()[e + 1] : this.getSpread()[e - 1];\n        return 1 === i.length ? this.pages[i[0]] : 0 === t ? this.pages[i[1]] : this.pages[i[0]];\n      }\n    }\n    showNext() {\n      this.currentSpreadIndex < this.getSpread().length && (this.currentSpreadIndex++, this.showSpread());\n    }\n    showPrev() {\n      this.currentSpreadIndex > 0 && (this.currentSpreadIndex--, this.showSpread());\n    }\n    getCurrentPageIndex() {\n      return this.currentPageIndex;\n    }\n    show(t = null) {\n      if (null === t && (t = this.currentPageIndex), t < 0 || t >= this.pages.length) return;\n      const e = this.getSpreadIndexByPage(t);\n      null !== e && (this.currentSpreadIndex = e, this.showSpread());\n    }\n    getCurrentSpreadIndex() {\n      return this.currentSpreadIndex;\n    }\n    setCurrentSpreadIndex(t) {\n      if (!(t >= 0 && t < this.getSpread().length)) throw new Error(\"Invalid page\");\n      this.currentSpreadIndex = t;\n    }\n    showSpread() {\n      const t = this.getSpread()[this.currentSpreadIndex];\n      2 === t.length ? (this.render.setLeftPage(this.pages[t[0]]), this.render.setRightPage(this.pages[t[1]])) : \"landscape\" === this.render.getOrientation() && t[0] === this.pages.length - 1 ? (this.render.setLeftPage(this.pages[t[0]]), this.render.setRightPage(null)) : (this.render.setLeftPage(null), this.render.setRightPage(this.pages[t[0]])), this.currentPageIndex = t[0], this.app.updatePageIndex(this.currentPageIndex);\n    }\n  }\n  class n extends s {\n    constructor(t, e, i) {\n      super(t, e), this.imagesHref = i;\n    }\n    load() {\n      for (const t of this.imagesHref) {\n        const e = new i(this.render, t, \"soft\");\n        e.load(), this.pages.push(e);\n      }\n      this.createSpread();\n    }\n  }\n  class h {\n    static GetDistanceBetweenTwoPoint(t, e) {\n      return null === t || null === e ? 1 / 0 : Math.sqrt(Math.pow(e.x - t.x, 2) + Math.pow(e.y - t.y, 2));\n    }\n    static GetSegmentLength(t) {\n      return h.GetDistanceBetweenTwoPoint(t[0], t[1]);\n    }\n    static GetAngleBetweenTwoLine(t, e) {\n      const i = t[0].y - t[1].y,\n        s = e[0].y - e[1].y,\n        n = t[1].x - t[0].x,\n        h = e[1].x - e[0].x;\n      return Math.acos((i * s + n * h) / (Math.sqrt(i * i + n * n) * Math.sqrt(s * s + h * h)));\n    }\n    static PointInRect(t, e) {\n      return null === e ? null : e.x >= t.left && e.x <= t.width + t.left && e.y >= t.top && e.y <= t.top + t.height ? e : null;\n    }\n    static GetRotatedPoint(t, e, i) {\n      return {\n        x: t.x * Math.cos(i) + t.y * Math.sin(i) + e.x,\n        y: t.y * Math.cos(i) - t.x * Math.sin(i) + e.y\n      };\n    }\n    static LimitPointToCircle(t, e, i) {\n      if (h.GetDistanceBetweenTwoPoint(t, i) <= e) return i;\n      const s = t.x,\n        n = t.y,\n        r = i.x,\n        o = i.y;\n      let a = Math.sqrt(Math.pow(e, 2) * Math.pow(s - r, 2) / (Math.pow(s - r, 2) + Math.pow(n - o, 2))) + s;\n      i.x < 0 && (a *= -1);\n      let g = (a - s) * (n - o) / (s - r) + n;\n      return s - r + n === 0 && (g = e), {\n        x: a,\n        y: g\n      };\n    }\n    static GetIntersectBetweenTwoSegment(t, e, i) {\n      return h.PointInRect(t, h.GetIntersectBeetwenTwoLine(e, i));\n    }\n    static GetIntersectBeetwenTwoLine(t, e) {\n      const i = t[0].y - t[1].y,\n        s = e[0].y - e[1].y,\n        n = t[1].x - t[0].x,\n        h = e[1].x - e[0].x,\n        r = t[0].x * t[1].y - t[1].x * t[0].y,\n        o = e[0].x * e[1].y - e[1].x * e[0].y,\n        a = i * o - s * r,\n        g = n * o - h * r,\n        l = -(r * h - o * n) / (i * h - s * n),\n        d = -(i * o - s * r) / (i * h - s * n);\n      if (isFinite(l) && isFinite(d)) return {\n        x: l,\n        y: d\n      };\n      if (Math.abs(a - g) < .1) throw new Error(\"Segment included\");\n      return null;\n    }\n    static GetCordsFromTwoPoint(t, e) {\n      const i = Math.abs(t.x - e.x),\n        s = Math.abs(t.y - e.y),\n        n = Math.max(i, s),\n        h = [t];\n      function r(t, e, i, s, n) {\n        return e > t ? t + n * (i / s) : e < t ? t - n * (i / s) : t;\n      }\n      for (let o = 1; o <= n; o += 1) h.push({\n        x: r(t.x, e.x, i, n, o),\n        y: r(t.y, e.y, s, n, o)\n      });\n      return h;\n    }\n  }\n  class r extends e {\n    constructor(t, e, i) {\n      super(t, i), this.copiedElement = null, this.temporaryCopy = null, this.isLoad = !1, this.element = e, this.element.classList.add(\"stf__item\"), this.element.classList.add(\"--\" + i);\n    }\n    newTemporaryCopy() {\n      return \"hard\" === this.nowDrawingDensity ? this : (null === this.temporaryCopy && (this.copiedElement = this.element.cloneNode(!0), this.element.parentElement.appendChild(this.copiedElement), this.temporaryCopy = new r(this.render, this.copiedElement, this.nowDrawingDensity)), this.getTemporaryCopy());\n    }\n    getTemporaryCopy() {\n      return this.temporaryCopy;\n    }\n    hideTemporaryCopy() {\n      null !== this.temporaryCopy && (this.copiedElement.remove(), this.copiedElement = null, this.temporaryCopy = null);\n    }\n    draw(t) {\n      const e = t || this.nowDrawingDensity,\n        i = this.render.convertToGlobal(this.state.position),\n        s = this.render.getRect().pageWidth,\n        n = this.render.getRect().height;\n      this.element.classList.remove(\"--simple\");\n      const h = `\\n            display: block;\\n            z-index: ${this.element.style.zIndex};\\n            left: 0;\\n            top: 0;\\n            width: ${s}px;\\n            height: ${n}px;\\n        `;\n      \"hard\" === e ? this.drawHard(h) : this.drawSoft(i, h);\n    }\n    drawHard(t = \"\") {\n      const e = this.render.getRect().left + this.render.getRect().width / 2,\n        i = this.state.hardDrawingAngle,\n        s = t + \"\\n                backface-visibility: hidden;\\n                -webkit-backface-visibility: hidden;\\n                clip-path: none;\\n                -webkit-clip-path: none;\\n            \" + (0 === this.orientation ? `transform-origin: ${this.render.getRect().pageWidth}px 0; \\n                   transform: translate3d(0, 0, 0) rotateY(${i}deg);` : `transform-origin: 0 0; \\n                   transform: translate3d(${e}px, 0, 0) rotateY(${i}deg);`);\n      this.element.style.cssText = s;\n    }\n    drawSoft(t, e = \"\") {\n      let i = \"polygon( \";\n      for (const t of this.state.area) if (null !== t) {\n        let e = 1 === this.render.getDirection() ? {\n          x: -t.x + this.state.position.x,\n          y: t.y - this.state.position.y\n        } : {\n          x: t.x - this.state.position.x,\n          y: t.y - this.state.position.y\n        };\n        e = h.GetRotatedPoint(e, {\n          x: 0,\n          y: 0\n        }, this.state.angle), i += e.x + \"px \" + e.y + \"px, \";\n      }\n      i = i.slice(0, -2), i += \")\";\n      const s = e + `transform-origin: 0 0; clip-path: ${i}; -webkit-clip-path: ${i};` + (this.render.isSafari() && 0 === this.state.angle ? `transform: translate(${t.x}px, ${t.y}px);` : `transform: translate3d(${t.x}px, ${t.y}px, 0) rotate(${this.state.angle}rad);`);\n      this.element.style.cssText = s;\n    }\n    simpleDraw(t) {\n      const e = this.render.getRect(),\n        i = e.pageWidth,\n        s = e.height,\n        n = 1 === t ? e.left + e.pageWidth : e.left,\n        h = e.top;\n      this.element.classList.add(\"--simple\"), this.element.style.cssText = `\\n            position: absolute; \\n            display: block; \\n            height: ${s}px; \\n            left: ${n}px; \\n            top: ${h}px; \\n            width: ${i}px; \\n            z-index: ${this.render.getSettings().startZIndex + 1};`;\n    }\n    getElement() {\n      return this.element;\n    }\n    load() {\n      this.isLoad = !0;\n    }\n    setOrientation(t) {\n      super.setOrientation(t), this.element.classList.remove(\"--left\", \"--right\"), this.element.classList.add(1 === t ? \"--right\" : \"--left\");\n    }\n    setDrawingDensity(t) {\n      this.element.classList.remove(\"--soft\", \"--hard\"), this.element.classList.add(\"--\" + t), super.setDrawingDensity(t);\n    }\n  }\n  class o extends s {\n    constructor(t, e, i, s) {\n      super(t, e), this.element = i, this.pagesElement = s;\n    }\n    load() {\n      for (const t of this.pagesElement) {\n        const e = new r(this.render, t, \"hard\" === t.dataset.density ? \"hard\" : \"soft\");\n        e.load(), this.pages.push(e);\n      }\n      this.createSpread();\n    }\n  }\n  class a {\n    constructor(t, e, i, s) {\n      this.direction = t, this.corner = e, this.topIntersectPoint = null, this.sideIntersectPoint = null, this.bottomIntersectPoint = null, this.pageWidth = parseInt(i, 10), this.pageHeight = parseInt(s, 10);\n    }\n    calc(t) {\n      try {\n        return this.position = this.calcAngleAndPosition(t), this.calculateIntersectPoint(this.position), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n    getFlippingClipArea() {\n      const t = [];\n      let e = !1;\n      return t.push(this.rect.topLeft), t.push(this.topIntersectPoint), null === this.sideIntersectPoint ? e = !0 : (t.push(this.sideIntersectPoint), null === this.bottomIntersectPoint && (e = !1)), t.push(this.bottomIntersectPoint), (e || \"bottom\" === this.corner) && t.push(this.rect.bottomLeft), t;\n    }\n    getBottomClipArea() {\n      const t = [];\n      return t.push(this.topIntersectPoint), \"top\" === this.corner ? t.push({\n        x: this.pageWidth,\n        y: 0\n      }) : (null !== this.topIntersectPoint && t.push({\n        x: this.pageWidth,\n        y: 0\n      }), t.push({\n        x: this.pageWidth,\n        y: this.pageHeight\n      })), null !== this.sideIntersectPoint ? h.GetDistanceBetweenTwoPoint(this.sideIntersectPoint, this.topIntersectPoint) >= 10 && t.push(this.sideIntersectPoint) : \"top\" === this.corner && t.push({\n        x: this.pageWidth,\n        y: this.pageHeight\n      }), t.push(this.bottomIntersectPoint), t.push(this.topIntersectPoint), t;\n    }\n    getAngle() {\n      return 0 === this.direction ? -this.angle : this.angle;\n    }\n    getRect() {\n      return this.rect;\n    }\n    getPosition() {\n      return this.position;\n    }\n    getActiveCorner() {\n      return 0 === this.direction ? this.rect.topLeft : this.rect.topRight;\n    }\n    getDirection() {\n      return this.direction;\n    }\n    getFlippingProgress() {\n      return Math.abs((this.position.x - this.pageWidth) / (2 * this.pageWidth) * 100);\n    }\n    getCorner() {\n      return this.corner;\n    }\n    getBottomPagePosition() {\n      return 1 === this.direction ? {\n        x: this.pageWidth,\n        y: 0\n      } : {\n        x: 0,\n        y: 0\n      };\n    }\n    getShadowStartPoint() {\n      return \"top\" === this.corner ? this.topIntersectPoint : null !== this.sideIntersectPoint ? this.sideIntersectPoint : this.topIntersectPoint;\n    }\n    getShadowAngle() {\n      const t = h.GetAngleBetweenTwoLine(this.getSegmentToShadowLine(), [{\n        x: 0,\n        y: 0\n      }, {\n        x: this.pageWidth,\n        y: 0\n      }]);\n      return 0 === this.direction ? t : Math.PI - t;\n    }\n    calcAngleAndPosition(t) {\n      let e = t;\n      if (this.updateAngleAndGeometry(e), e = \"top\" === this.corner ? this.checkPositionAtCenterLine(e, {\n        x: 0,\n        y: 0\n      }, {\n        x: 0,\n        y: this.pageHeight\n      }) : this.checkPositionAtCenterLine(e, {\n        x: 0,\n        y: this.pageHeight\n      }, {\n        x: 0,\n        y: 0\n      }), Math.abs(e.x - this.pageWidth) < 1 && Math.abs(e.y) < 1) throw new Error(\"Point is too small\");\n      return e;\n    }\n    updateAngleAndGeometry(t) {\n      this.angle = this.calculateAngle(t), this.rect = this.getPageRect(t);\n    }\n    calculateAngle(t) {\n      const e = this.pageWidth - t.x + 1,\n        i = \"bottom\" === this.corner ? this.pageHeight - t.y : t.y;\n      let s = 2 * Math.acos(e / Math.sqrt(i * i + e * e));\n      i < 0 && (s = -s);\n      const n = Math.PI - s;\n      if (!isFinite(s) || n >= 0 && n < .003) throw new Error(\"The G point is too small\");\n      return \"bottom\" === this.corner && (s = -s), s;\n    }\n    getPageRect(t) {\n      return \"top\" === this.corner ? this.getRectFromBasePoint([{\n        x: 0,\n        y: 0\n      }, {\n        x: this.pageWidth,\n        y: 0\n      }, {\n        x: 0,\n        y: this.pageHeight\n      }, {\n        x: this.pageWidth,\n        y: this.pageHeight\n      }], t) : this.getRectFromBasePoint([{\n        x: 0,\n        y: -this.pageHeight\n      }, {\n        x: this.pageWidth,\n        y: -this.pageHeight\n      }, {\n        x: 0,\n        y: 0\n      }, {\n        x: this.pageWidth,\n        y: 0\n      }], t);\n    }\n    getRectFromBasePoint(t, e) {\n      return {\n        topLeft: this.getRotatedPoint(t[0], e),\n        topRight: this.getRotatedPoint(t[1], e),\n        bottomLeft: this.getRotatedPoint(t[2], e),\n        bottomRight: this.getRotatedPoint(t[3], e)\n      };\n    }\n    getRotatedPoint(t, e) {\n      return {\n        x: t.x * Math.cos(this.angle) + t.y * Math.sin(this.angle) + e.x,\n        y: t.y * Math.cos(this.angle) - t.x * Math.sin(this.angle) + e.y\n      };\n    }\n    calculateIntersectPoint(t) {\n      const e = {\n        left: -1,\n        top: -1,\n        width: this.pageWidth + 2,\n        height: this.pageHeight + 2\n      };\n      \"top\" === this.corner ? (this.topIntersectPoint = h.GetIntersectBetweenTwoSegment(e, [t, this.rect.topRight], [{\n        x: 0,\n        y: 0\n      }, {\n        x: this.pageWidth,\n        y: 0\n      }]), this.sideIntersectPoint = h.GetIntersectBetweenTwoSegment(e, [t, this.rect.bottomLeft], [{\n        x: this.pageWidth,\n        y: 0\n      }, {\n        x: this.pageWidth,\n        y: this.pageHeight\n      }]), this.bottomIntersectPoint = h.GetIntersectBetweenTwoSegment(e, [this.rect.bottomLeft, this.rect.bottomRight], [{\n        x: 0,\n        y: this.pageHeight\n      }, {\n        x: this.pageWidth,\n        y: this.pageHeight\n      }])) : (this.topIntersectPoint = h.GetIntersectBetweenTwoSegment(e, [this.rect.topLeft, this.rect.topRight], [{\n        x: 0,\n        y: 0\n      }, {\n        x: this.pageWidth,\n        y: 0\n      }]), this.sideIntersectPoint = h.GetIntersectBetweenTwoSegment(e, [t, this.rect.topLeft], [{\n        x: this.pageWidth,\n        y: 0\n      }, {\n        x: this.pageWidth,\n        y: this.pageHeight\n      }]), this.bottomIntersectPoint = h.GetIntersectBetweenTwoSegment(e, [this.rect.bottomLeft, this.rect.bottomRight], [{\n        x: 0,\n        y: this.pageHeight\n      }, {\n        x: this.pageWidth,\n        y: this.pageHeight\n      }]));\n    }\n    checkPositionAtCenterLine(t, e, i) {\n      let s = t;\n      const n = h.LimitPointToCircle(e, this.pageWidth, s);\n      s !== n && (s = n, this.updateAngleAndGeometry(s));\n      const r = Math.sqrt(Math.pow(this.pageWidth, 2) + Math.pow(this.pageHeight, 2));\n      let o = this.rect.bottomRight,\n        a = this.rect.topLeft;\n      if (\"bottom\" === this.corner && (o = this.rect.topRight, a = this.rect.bottomLeft), o.x <= 0) {\n        const t = h.LimitPointToCircle(i, r, a);\n        t !== s && (s = t, this.updateAngleAndGeometry(s));\n      }\n      return s;\n    }\n    getSegmentToShadowLine() {\n      const t = this.getShadowStartPoint();\n      return [t, t !== this.sideIntersectPoint && null !== this.sideIntersectPoint ? this.sideIntersectPoint : this.bottomIntersectPoint];\n    }\n  }\n  class g {\n    constructor(t, e) {\n      this.flippingPage = null, this.bottomPage = null, this.calc = null, this.state = \"read\", this.render = t, this.app = e;\n    }\n    fold(t) {\n      this.setState(\"user_fold\"), null === this.calc && this.start(t), this.do(this.render.convertToPage(t));\n    }\n    flip(t) {\n      if (this.app.getSettings().disableFlipByClick && !this.isPointOnCorners(t)) return;\n      if (null !== this.calc && this.render.finishAnimation(), !this.start(t)) return;\n      const e = this.getBoundsRect();\n      this.setState(\"flipping\");\n      const i = e.height / 10,\n        s = \"bottom\" === this.calc.getCorner() ? e.height - i : i,\n        n = \"bottom\" === this.calc.getCorner() ? e.height : 0;\n      this.calc.calc({\n        x: e.pageWidth - i,\n        y: s\n      }), this.animateFlippingTo({\n        x: e.pageWidth - i,\n        y: s\n      }, {\n        x: -e.pageWidth,\n        y: n\n      }, !0);\n    }\n    start(t) {\n      this.reset();\n      const e = this.render.convertToBook(t),\n        i = this.getBoundsRect(),\n        s = this.getDirectionByPoint(e),\n        n = e.y >= i.height / 2 ? \"bottom\" : \"top\";\n      if (!this.checkDirection(s)) return !1;\n      try {\n        if (this.flippingPage = this.app.getPageCollection().getFlippingPage(s), this.bottomPage = this.app.getPageCollection().getBottomPage(s), \"landscape\" === this.render.getOrientation()) if (1 === s) {\n          const t = this.app.getPageCollection().nextBy(this.flippingPage);\n          null !== t && this.flippingPage.getDensity() !== t.getDensity() && (this.flippingPage.setDrawingDensity(\"hard\"), t.setDrawingDensity(\"hard\"));\n        } else {\n          const t = this.app.getPageCollection().prevBy(this.flippingPage);\n          null !== t && this.flippingPage.getDensity() !== t.getDensity() && (this.flippingPage.setDrawingDensity(\"hard\"), t.setDrawingDensity(\"hard\"));\n        }\n        return this.render.setDirection(s), this.calc = new a(s, n, i.pageWidth.toString(10), i.height.toString(10)), !0;\n      } catch (t) {\n        return !1;\n      }\n    }\n    do(t) {\n      if (null !== this.calc && this.calc.calc(t)) {\n        const t = this.calc.getFlippingProgress();\n        this.bottomPage.setArea(this.calc.getBottomClipArea()), this.bottomPage.setPosition(this.calc.getBottomPagePosition()), this.bottomPage.setAngle(0), this.bottomPage.setHardAngle(0), this.flippingPage.setArea(this.calc.getFlippingClipArea()), this.flippingPage.setPosition(this.calc.getActiveCorner()), this.flippingPage.setAngle(this.calc.getAngle()), 0 === this.calc.getDirection() ? this.flippingPage.setHardAngle(90 * (200 - 2 * t) / 100) : this.flippingPage.setHardAngle(-90 * (200 - 2 * t) / 100), this.render.setPageRect(this.calc.getRect()), this.render.setBottomPage(this.bottomPage), this.render.setFlippingPage(this.flippingPage), this.render.setShadowData(this.calc.getShadowStartPoint(), this.calc.getShadowAngle(), t, this.calc.getDirection());\n      }\n    }\n    flipToPage(t, e) {\n      const i = this.app.getPageCollection().getCurrentSpreadIndex(),\n        s = this.app.getPageCollection().getSpreadIndexByPage(t);\n      try {\n        s > i && (this.app.getPageCollection().setCurrentSpreadIndex(s - 1), this.flipNext(e)), s < i && (this.app.getPageCollection().setCurrentSpreadIndex(s + 1), this.flipPrev(e));\n      } catch (t) {}\n    }\n    flipNext(t) {\n      this.flip({\n        x: this.render.getRect().left + 2 * this.render.getRect().pageWidth - 10,\n        y: \"top\" === t ? 1 : this.render.getRect().height - 2\n      });\n    }\n    flipPrev(t) {\n      this.flip({\n        x: 10,\n        y: \"top\" === t ? 1 : this.render.getRect().height - 2\n      });\n    }\n    stopMove() {\n      if (null === this.calc) return;\n      const t = this.calc.getPosition(),\n        e = this.getBoundsRect(),\n        i = \"bottom\" === this.calc.getCorner() ? e.height : 0;\n      t.x <= 0 ? this.animateFlippingTo(t, {\n        x: -e.pageWidth,\n        y: i\n      }, !0) : this.animateFlippingTo(t, {\n        x: e.pageWidth,\n        y: i\n      }, !1);\n    }\n    showCorner(t) {\n      if (!this.checkState(\"read\", \"fold_corner\")) return;\n      const e = this.getBoundsRect(),\n        i = e.pageWidth;\n      if (this.isPointOnCorners(t)) {\n        if (null === this.calc) {\n          if (!this.start(t)) return;\n          this.setState(\"fold_corner\"), this.calc.calc({\n            x: i - 1,\n            y: 1\n          });\n          const s = 50,\n            n = \"bottom\" === this.calc.getCorner() ? e.height - 1 : 1,\n            h = \"bottom\" === this.calc.getCorner() ? e.height - s : s;\n          this.animateFlippingTo({\n            x: i - 1,\n            y: n\n          }, {\n            x: i - s,\n            y: h\n          }, !1, !1);\n        } else this.do(this.render.convertToPage(t));\n      } else this.setState(\"read\"), this.render.finishAnimation(), this.stopMove();\n    }\n    animateFlippingTo(t, e, i, s = !0) {\n      const n = h.GetCordsFromTwoPoint(t, e),\n        r = [];\n      for (const t of n) r.push(() => this.do(t));\n      const o = this.getAnimationDuration(n.length);\n      this.render.startAnimation(r, o, () => {\n        this.calc && (i && (1 === this.calc.getDirection() ? this.app.turnToPrevPage() : this.app.turnToNextPage()), s && (this.render.setBottomPage(null), this.render.setFlippingPage(null), this.render.clearShadow(), this.setState(\"read\"), this.reset()));\n      });\n    }\n    getCalculation() {\n      return this.calc;\n    }\n    getState() {\n      return this.state;\n    }\n    setState(t) {\n      this.state !== t && (this.app.updateState(t), this.state = t);\n    }\n    getDirectionByPoint(t) {\n      const e = this.getBoundsRect();\n      if (\"portrait\" === this.render.getOrientation()) {\n        if (t.x - e.pageWidth <= e.width / 5) return 1;\n      } else if (t.x < e.width / 2) return 1;\n      return 0;\n    }\n    getAnimationDuration(t) {\n      const e = this.app.getSettings().flippingTime;\n      return t >= 1e3 ? e : t / 1e3 * e;\n    }\n    checkDirection(t) {\n      return 0 === t ? this.app.getCurrentPageIndex() < this.app.getPageCount() - 1 : this.app.getCurrentPageIndex() >= 1;\n    }\n    reset() {\n      this.calc = null, this.flippingPage = null, this.bottomPage = null;\n    }\n    getBoundsRect() {\n      return this.render.getRect();\n    }\n    checkState(...t) {\n      for (const e of t) if (this.state === e) return !0;\n      return !1;\n    }\n    isPointOnCorners(t) {\n      const e = this.getBoundsRect(),\n        i = e.pageWidth,\n        s = Math.sqrt(Math.pow(i, 2) + Math.pow(e.height, 2)) / 5,\n        n = this.render.convertToBook(t);\n      return n.x > 0 && n.y > 0 && n.x < e.width && n.y < e.height && (n.x < s || n.x > e.width - s) && (n.y < s || n.y > e.height - s);\n    }\n  }\n  class l {\n    constructor(t, e) {\n      this.leftPage = null, this.rightPage = null, this.flippingPage = null, this.bottomPage = null, this.direction = null, this.orientation = null, this.shadow = null, this.animation = null, this.pageRect = null, this.boundsRect = null, this.timer = 0, this.safari = !1, this.setting = e, this.app = t;\n      const i = new RegExp(\"Version\\\\/[\\\\d\\\\.]+.*Safari/\");\n      this.safari = null !== i.exec(window.navigator.userAgent);\n    }\n    render(t) {\n      if (null !== this.animation) {\n        const e = Math.round((t - this.animation.startedAt) / this.animation.durationFrame);\n        e < this.animation.frames.length ? this.animation.frames[e]() : (this.animation.onAnimateEnd(), this.animation = null);\n      }\n      this.timer = t, this.drawFrame();\n    }\n    start() {\n      this.update();\n      const t = e => {\n        this.render(e), requestAnimationFrame(t);\n      };\n      requestAnimationFrame(t);\n    }\n    startAnimation(t, e, i) {\n      this.finishAnimation(), this.animation = {\n        frames: t,\n        duration: e,\n        durationFrame: e / t.length,\n        onAnimateEnd: i,\n        startedAt: this.timer\n      };\n    }\n    finishAnimation() {\n      null !== this.animation && (this.animation.frames[this.animation.frames.length - 1](), null !== this.animation.onAnimateEnd && this.animation.onAnimateEnd()), this.animation = null;\n    }\n    update() {\n      this.boundsRect = null;\n      const t = this.calculateBoundsRect();\n      this.orientation !== t && (this.orientation = t, this.app.updateOrientation(t));\n    }\n    calculateBoundsRect() {\n      let t = \"landscape\";\n      const e = this.getBlockWidth(),\n        i = e / 2,\n        s = this.getBlockHeight() / 2,\n        n = this.setting.width / this.setting.height;\n      let h = this.setting.width,\n        r = this.setting.height,\n        o = i - h;\n      return \"stretch\" === this.setting.size ? (e < 2 * this.setting.minWidth && this.app.getSettings().usePortrait && (t = \"portrait\"), h = \"portrait\" === t ? this.getBlockWidth() : this.getBlockWidth() / 2, h > this.setting.maxWidth && (h = this.setting.maxWidth), r = h / n, r > this.getBlockHeight() && (r = this.getBlockHeight(), h = r * n), o = \"portrait\" === t ? i - h / 2 - h : i - h) : e < 2 * h && this.app.getSettings().usePortrait && (t = \"portrait\", o = i - h / 2 - h), this.boundsRect = {\n        left: o,\n        top: s - r / 2,\n        width: 2 * h,\n        height: r,\n        pageWidth: h\n      }, t;\n    }\n    setShadowData(t, e, i, s) {\n      if (!this.app.getSettings().drawShadow) return;\n      const n = 100 * this.getSettings().maxShadowOpacity;\n      this.shadow = {\n        pos: t,\n        angle: e,\n        width: 3 * this.getRect().pageWidth / 4 * i / 100,\n        opacity: (100 - i) * n / 100 / 100,\n        direction: s,\n        progress: 2 * i\n      };\n    }\n    clearShadow() {\n      this.shadow = null;\n    }\n    getBlockWidth() {\n      return this.app.getUI().getDistElement().offsetWidth;\n    }\n    getBlockHeight() {\n      return this.app.getUI().getDistElement().offsetHeight;\n    }\n    getDirection() {\n      return this.direction;\n    }\n    getRect() {\n      return null === this.boundsRect && this.calculateBoundsRect(), this.boundsRect;\n    }\n    getSettings() {\n      return this.app.getSettings();\n    }\n    getOrientation() {\n      return this.orientation;\n    }\n    setPageRect(t) {\n      this.pageRect = t;\n    }\n    setDirection(t) {\n      this.direction = t;\n    }\n    setRightPage(t) {\n      null !== t && t.setOrientation(1), this.rightPage = t;\n    }\n    setLeftPage(t) {\n      null !== t && t.setOrientation(0), this.leftPage = t;\n    }\n    setBottomPage(t) {\n      null !== t && t.setOrientation(1 === this.direction ? 0 : 1), this.bottomPage = t;\n    }\n    setFlippingPage(t) {\n      null !== t && t.setOrientation(0 === this.direction && \"portrait\" !== this.orientation ? 0 : 1), this.flippingPage = t;\n    }\n    convertToBook(t) {\n      const e = this.getRect();\n      return {\n        x: t.x - e.left,\n        y: t.y - e.top\n      };\n    }\n    isSafari() {\n      return this.safari;\n    }\n    convertToPage(t, e) {\n      e || (e = this.direction);\n      const i = this.getRect();\n      return {\n        x: 0 === e ? t.x - i.left - i.width / 2 : i.width / 2 - t.x + i.left,\n        y: t.y - i.top\n      };\n    }\n    convertToGlobal(t, e) {\n      if (e || (e = this.direction), null == t) return null;\n      const i = this.getRect();\n      return {\n        x: 0 === e ? t.x + i.left + i.width / 2 : i.width / 2 - t.x + i.left,\n        y: t.y + i.top\n      };\n    }\n    convertRectToGlobal(t, e) {\n      return e || (e = this.direction), {\n        topLeft: this.convertToGlobal(t.topLeft, e),\n        topRight: this.convertToGlobal(t.topRight, e),\n        bottomLeft: this.convertToGlobal(t.bottomLeft, e),\n        bottomRight: this.convertToGlobal(t.bottomRight, e)\n      };\n    }\n  }\n  class d extends l {\n    constructor(t, e, i) {\n      super(t, e), this.canvas = i, this.ctx = i.getContext(\"2d\");\n    }\n    getContext() {\n      return this.ctx;\n    }\n    reload() {}\n    drawFrame() {\n      this.clear(), \"portrait\" !== this.orientation && null != this.leftPage && this.leftPage.simpleDraw(0), null != this.rightPage && this.rightPage.simpleDraw(1), null != this.bottomPage && this.bottomPage.draw(), this.drawBookShadow(), null != this.flippingPage && this.flippingPage.draw(), null != this.shadow && (this.drawOuterShadow(), this.drawInnerShadow());\n      const t = this.getRect();\n      \"portrait\" === this.orientation && (this.ctx.beginPath(), this.ctx.rect(t.left + t.pageWidth, t.top, t.width, t.height), this.ctx.clip());\n    }\n    drawBookShadow() {\n      const t = this.getRect();\n      this.ctx.save(), this.ctx.beginPath();\n      const e = t.width / 20;\n      this.ctx.rect(t.left, t.top, t.width, t.height);\n      const i = {\n        x: t.left + t.width / 2 - e / 2,\n        y: 0\n      };\n      this.ctx.translate(i.x, i.y);\n      const s = this.ctx.createLinearGradient(0, 0, e, 0);\n      s.addColorStop(0, \"rgba(0, 0, 0, 0)\"), s.addColorStop(.4, \"rgba(0, 0, 0, 0.2)\"), s.addColorStop(.49, \"rgba(0, 0, 0, 0.1)\"), s.addColorStop(.5, \"rgba(0, 0, 0, 0.5)\"), s.addColorStop(.51, \"rgba(0, 0, 0, 0.4)\"), s.addColorStop(1, \"rgba(0, 0, 0, 0)\"), this.ctx.clip(), this.ctx.fillStyle = s, this.ctx.fillRect(0, 0, e, 2 * t.height), this.ctx.restore();\n    }\n    drawOuterShadow() {\n      const t = this.getRect();\n      this.ctx.save(), this.ctx.beginPath(), this.ctx.rect(t.left, t.top, t.width, t.height);\n      const e = this.convertToGlobal({\n        x: this.shadow.pos.x,\n        y: this.shadow.pos.y\n      });\n      this.ctx.translate(e.x, e.y), this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\n      const i = this.ctx.createLinearGradient(0, 0, this.shadow.width, 0);\n      0 === this.shadow.direction ? (this.ctx.translate(0, -100), i.addColorStop(0, \"rgba(0, 0, 0, \" + this.shadow.opacity + \")\"), i.addColorStop(1, \"rgba(0, 0, 0, 0)\")) : (this.ctx.translate(-this.shadow.width, -100), i.addColorStop(0, \"rgba(0, 0, 0, 0)\"), i.addColorStop(1, \"rgba(0, 0, 0, \" + this.shadow.opacity + \")\")), this.ctx.clip(), this.ctx.fillStyle = i, this.ctx.fillRect(0, 0, this.shadow.width, 2 * t.height), this.ctx.restore();\n    }\n    drawInnerShadow() {\n      const t = this.getRect();\n      this.ctx.save(), this.ctx.beginPath();\n      const e = this.convertToGlobal({\n          x: this.shadow.pos.x,\n          y: this.shadow.pos.y\n        }),\n        i = this.convertRectToGlobal(this.pageRect);\n      this.ctx.moveTo(i.topLeft.x, i.topLeft.y), this.ctx.lineTo(i.topRight.x, i.topRight.y), this.ctx.lineTo(i.bottomRight.x, i.bottomRight.y), this.ctx.lineTo(i.bottomLeft.x, i.bottomLeft.y), this.ctx.translate(e.x, e.y), this.ctx.rotate(Math.PI + this.shadow.angle + Math.PI / 2);\n      const s = 3 * this.shadow.width / 4,\n        n = this.ctx.createLinearGradient(0, 0, s, 0);\n      0 === this.shadow.direction ? (this.ctx.translate(-s, -100), n.addColorStop(1, \"rgba(0, 0, 0, \" + this.shadow.opacity + \")\"), n.addColorStop(.9, \"rgba(0, 0, 0, 0.05)\"), n.addColorStop(.7, \"rgba(0, 0, 0, \" + this.shadow.opacity + \")\"), n.addColorStop(0, \"rgba(0, 0, 0, 0)\")) : (this.ctx.translate(0, -100), n.addColorStop(0, \"rgba(0, 0, 0, \" + this.shadow.opacity + \")\"), n.addColorStop(.1, \"rgba(0, 0, 0, 0.05)\"), n.addColorStop(.3, \"rgba(0, 0, 0, \" + this.shadow.opacity + \")\"), n.addColorStop(1, \"rgba(0, 0, 0, 0)\")), this.ctx.clip(), this.ctx.fillStyle = n, this.ctx.fillRect(0, 0, s, 2 * t.height), this.ctx.restore();\n    }\n    clear() {\n      this.ctx.fillStyle = \"white\", this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);\n    }\n  }\n  class p {\n    constructor(t, e, i) {\n      this.touchPoint = null, this.swipeTimeout = 250, this.onResize = () => {\n        this.update();\n      }, this.onMouseDown = t => {\n        if (this.checkTarget(t.target)) {\n          const e = this.getMousePos(t.clientX, t.clientY);\n          this.app.startUserTouch(e), t.preventDefault();\n        }\n      }, this.onTouchStart = t => {\n        if (this.checkTarget(t.target) && t.changedTouches.length > 0) {\n          const e = t.changedTouches[0],\n            i = this.getMousePos(e.clientX, e.clientY);\n          this.touchPoint = {\n            point: i,\n            time: Date.now()\n          }, setTimeout(() => {\n            null !== this.touchPoint && this.app.startUserTouch(i);\n          }, this.swipeTimeout), this.app.getSettings().mobileScrollSupport || t.preventDefault();\n        }\n      }, this.onMouseUp = t => {\n        const e = this.getMousePos(t.clientX, t.clientY);\n        this.app.userStop(e);\n      }, this.onMouseMove = t => {\n        const e = this.getMousePos(t.clientX, t.clientY);\n        this.app.userMove(e, !1);\n      }, this.onTouchMove = t => {\n        if (t.changedTouches.length > 0) {\n          const e = t.changedTouches[0],\n            i = this.getMousePos(e.clientX, e.clientY);\n          this.app.getSettings().mobileScrollSupport ? (null !== this.touchPoint && (Math.abs(this.touchPoint.point.x - i.x) > 10 || \"read\" !== this.app.getState()) && t.cancelable && this.app.userMove(i, !0), \"read\" !== this.app.getState() && t.preventDefault()) : this.app.userMove(i, !0);\n        }\n      }, this.onTouchEnd = t => {\n        if (t.changedTouches.length > 0) {\n          const e = t.changedTouches[0],\n            i = this.getMousePos(e.clientX, e.clientY);\n          let s = !1;\n          if (null !== this.touchPoint) {\n            const t = i.x - this.touchPoint.point.x,\n              e = Math.abs(i.y - this.touchPoint.point.y);\n            Math.abs(t) > this.swipeDistance && e < 2 * this.swipeDistance && Date.now() - this.touchPoint.time < this.swipeTimeout && (t > 0 ? this.app.flipPrev(this.touchPoint.point.y < this.app.getRender().getRect().height / 2 ? \"top\" : \"bottom\") : this.app.flipNext(this.touchPoint.point.y < this.app.getRender().getRect().height / 2 ? \"top\" : \"bottom\"), s = !0), this.touchPoint = null;\n          }\n          this.app.userStop(i, s);\n        }\n      }, this.parentElement = t, t.classList.add(\"stf__parent\"), t.insertAdjacentHTML(\"afterbegin\", '<div class=\"stf__wrapper\"></div>'), this.wrapper = t.querySelector(\".stf__wrapper\"), this.app = e;\n      const s = this.app.getSettings().usePortrait ? 1 : 2;\n      t.style.minWidth = i.minWidth * s + \"px\", t.style.minHeight = i.minHeight + \"px\", \"fixed\" === i.size && (t.style.minWidth = i.width * s + \"px\", t.style.minHeight = i.height + \"px\"), i.autoSize && (t.style.width = \"100%\", t.style.maxWidth = 2 * i.maxWidth + \"px\"), t.style.display = \"block\", window.addEventListener(\"resize\", this.onResize, !1), this.swipeDistance = i.swipeDistance;\n    }\n    destroy() {\n      this.app.getSettings().useMouseEvents && this.removeHandlers(), this.distElement.remove(), this.wrapper.remove();\n    }\n    getDistElement() {\n      return this.distElement;\n    }\n    getWrapper() {\n      return this.wrapper;\n    }\n    setOrientationStyle(t) {\n      this.wrapper.classList.remove(\"--portrait\", \"--landscape\"), \"portrait\" === t ? (this.app.getSettings().autoSize && (this.wrapper.style.paddingBottom = this.app.getSettings().height / this.app.getSettings().width * 100 + \"%\"), this.wrapper.classList.add(\"--portrait\")) : (this.app.getSettings().autoSize && (this.wrapper.style.paddingBottom = this.app.getSettings().height / (2 * this.app.getSettings().width) * 100 + \"%\"), this.wrapper.classList.add(\"--landscape\")), this.update();\n    }\n    removeHandlers() {\n      window.removeEventListener(\"resize\", this.onResize), this.distElement.removeEventListener(\"mousedown\", this.onMouseDown), this.distElement.removeEventListener(\"touchstart\", this.onTouchStart), window.removeEventListener(\"mousemove\", this.onMouseMove), window.removeEventListener(\"touchmove\", this.onTouchMove), window.removeEventListener(\"mouseup\", this.onMouseUp), window.removeEventListener(\"touchend\", this.onTouchEnd);\n    }\n    setHandlers() {\n      window.addEventListener(\"resize\", this.onResize, !1), this.app.getSettings().useMouseEvents && (this.distElement.addEventListener(\"mousedown\", this.onMouseDown), this.distElement.addEventListener(\"touchstart\", this.onTouchStart), window.addEventListener(\"mousemove\", this.onMouseMove), window.addEventListener(\"touchmove\", this.onTouchMove, {\n        passive: !this.app.getSettings().mobileScrollSupport\n      }), window.addEventListener(\"mouseup\", this.onMouseUp), window.addEventListener(\"touchend\", this.onTouchEnd));\n    }\n    getMousePos(t, e) {\n      const i = this.distElement.getBoundingClientRect();\n      return {\n        x: t - i.left,\n        y: e - i.top\n      };\n    }\n    checkTarget(t) {\n      return !this.app.getSettings().clickEventForward || ![\"a\", \"button\"].includes(t.tagName.toLowerCase());\n    }\n  }\n  class c extends p {\n    constructor(t, e, i, s) {\n      super(t, e, i), this.wrapper.insertAdjacentHTML(\"afterbegin\", '<div class=\"stf__block\"></div>'), this.distElement = t.querySelector(\".stf__block\"), this.items = s;\n      for (const t of s) this.distElement.appendChild(t);\n      this.setHandlers();\n    }\n    clear() {\n      for (const t of this.items) this.parentElement.appendChild(t);\n    }\n    updateItems(t) {\n      this.removeHandlers(), this.distElement.innerHTML = \"\";\n      for (const e of t) this.distElement.appendChild(e);\n      this.items = t, this.setHandlers();\n    }\n    update() {\n      this.app.getRender().update();\n    }\n  }\n  class u extends p {\n    constructor(t, e, i) {\n      super(t, e, i), this.wrapper.innerHTML = '<canvas class=\"stf__canvas\"></canvas>', this.canvas = t.querySelectorAll(\"canvas\")[0], this.distElement = this.canvas, this.resizeCanvas(), this.setHandlers();\n    }\n    resizeCanvas() {\n      const t = getComputedStyle(this.canvas),\n        e = parseInt(t.getPropertyValue(\"width\"), 10),\n        i = parseInt(t.getPropertyValue(\"height\"), 10);\n      this.canvas.width = e, this.canvas.height = i;\n    }\n    getCanvas() {\n      return this.canvas;\n    }\n    update() {\n      this.resizeCanvas(), this.app.getRender().update();\n    }\n  }\n  class w extends l {\n    constructor(t, e, i) {\n      super(t, e), this.outerShadow = null, this.innerShadow = null, this.hardShadow = null, this.hardInnerShadow = null, this.element = i, this.createShadows();\n    }\n    createShadows() {\n      this.element.insertAdjacentHTML(\"beforeend\", '<div class=\"stf__outerShadow\"></div>\\n             <div class=\"stf__innerShadow\"></div>\\n             <div class=\"stf__hardShadow\"></div>\\n             <div class=\"stf__hardInnerShadow\"></div>'), this.outerShadow = this.element.querySelector(\".stf__outerShadow\"), this.innerShadow = this.element.querySelector(\".stf__innerShadow\"), this.hardShadow = this.element.querySelector(\".stf__hardShadow\"), this.hardInnerShadow = this.element.querySelector(\".stf__hardInnerShadow\");\n    }\n    clearShadow() {\n      super.clearShadow(), this.outerShadow.style.cssText = \"display: none\", this.innerShadow.style.cssText = \"display: none\", this.hardShadow.style.cssText = \"display: none\", this.hardInnerShadow.style.cssText = \"display: none\";\n    }\n    reload() {\n      this.element.querySelector(\".stf__outerShadow\") || this.createShadows();\n    }\n    drawHardInnerShadow() {\n      const t = this.getRect(),\n        e = this.shadow.progress > 100 ? 200 - this.shadow.progress : this.shadow.progress;\n      let i = (100 - e) * (2.5 * t.pageWidth) / 100 + 20;\n      i > t.pageWidth && (i = t.pageWidth);\n      let s = `\\n            display: block;\\n            z-index: ${(this.getSettings().startZIndex + 5).toString(10)};\\n            width: ${i}px;\\n            height: ${t.height}px;\\n            background: linear-gradient(to right,\\n                rgba(0, 0, 0, ${this.shadow.opacity * e / 100}) 5%,\\n                rgba(0, 0, 0, 0) 100%);\\n            left: ${t.left + t.width / 2}px;\\n            transform-origin: 0 0;\\n        `;\n      s += 0 === this.getDirection() && this.shadow.progress > 100 || 1 === this.getDirection() && this.shadow.progress <= 100 ? \"transform: translate3d(0, 0, 0);\" : \"transform: translate3d(0, 0, 0) rotateY(180deg);\", this.hardInnerShadow.style.cssText = s;\n    }\n    drawHardOuterShadow() {\n      const t = this.getRect();\n      let e = (100 - (this.shadow.progress > 100 ? 200 - this.shadow.progress : this.shadow.progress)) * (2.5 * t.pageWidth) / 100 + 20;\n      e > t.pageWidth && (e = t.pageWidth);\n      let i = `\\n            display: block;\\n            z-index: ${(this.getSettings().startZIndex + 4).toString(10)};\\n            width: ${e}px;\\n            height: ${t.height}px;\\n            background: linear-gradient(to left, rgba(0, 0, 0, ${this.shadow.opacity}) 5%, rgba(0, 0, 0, 0) 100%);\\n            left: ${t.left + t.width / 2}px;\\n            transform-origin: 0 0;\\n        `;\n      i += 0 === this.getDirection() && this.shadow.progress > 100 || 1 === this.getDirection() && this.shadow.progress <= 100 ? \"transform: translate3d(0, 0, 0) rotateY(180deg);\" : \"transform: translate3d(0, 0, 0);\", this.hardShadow.style.cssText = i;\n    }\n    drawInnerShadow() {\n      const t = this.getRect(),\n        e = 3 * this.shadow.width / 4,\n        i = 0 === this.getDirection() ? e : 0,\n        s = 0 === this.getDirection() ? \"to left\" : \"to right\",\n        n = this.convertToGlobal(this.shadow.pos),\n        r = this.shadow.angle + 3 * Math.PI / 2,\n        o = [this.pageRect.topLeft, this.pageRect.topRight, this.pageRect.bottomRight, this.pageRect.bottomLeft];\n      let a = \"polygon( \";\n      for (const t of o) {\n        let e = 1 === this.getDirection() ? {\n          x: -t.x + this.shadow.pos.x,\n          y: t.y - this.shadow.pos.y\n        } : {\n          x: t.x - this.shadow.pos.x,\n          y: t.y - this.shadow.pos.y\n        };\n        e = h.GetRotatedPoint(e, {\n          x: i,\n          y: 100\n        }, r), a += e.x + \"px \" + e.y + \"px, \";\n      }\n      a = a.slice(0, -2), a += \")\";\n      const g = `\\n            display: block;\\n            z-index: ${(this.getSettings().startZIndex + 10).toString(10)};\\n            width: ${e}px;\\n            height: ${2 * t.height}px;\\n            background: linear-gradient(${s},\\n                rgba(0, 0, 0, ${this.shadow.opacity}) 5%,\\n                rgba(0, 0, 0, 0.05) 15%,\\n                rgba(0, 0, 0, ${this.shadow.opacity}) 35%,\\n                rgba(0, 0, 0, 0) 100%);\\n            transform-origin: ${i}px 100px;\\n            transform: translate3d(${n.x - i}px, ${n.y - 100}px, 0) rotate(${r}rad);\\n            clip-path: ${a};\\n            -webkit-clip-path: ${a};\\n        `;\n      this.innerShadow.style.cssText = g;\n    }\n    drawOuterShadow() {\n      const t = this.getRect(),\n        e = this.convertToGlobal({\n          x: this.shadow.pos.x,\n          y: this.shadow.pos.y\n        }),\n        i = this.shadow.angle + 3 * Math.PI / 2,\n        s = 1 === this.getDirection() ? this.shadow.width : 0,\n        n = 0 === this.getDirection() ? \"to right\" : \"to left\",\n        r = [{\n          x: 0,\n          y: 0\n        }, {\n          x: t.pageWidth,\n          y: 0\n        }, {\n          x: t.pageWidth,\n          y: t.height\n        }, {\n          x: 0,\n          y: t.height\n        }];\n      let o = \"polygon( \";\n      for (const t of r) if (null !== t) {\n        let e = 1 === this.getDirection() ? {\n          x: -t.x + this.shadow.pos.x,\n          y: t.y - this.shadow.pos.y\n        } : {\n          x: t.x - this.shadow.pos.x,\n          y: t.y - this.shadow.pos.y\n        };\n        e = h.GetRotatedPoint(e, {\n          x: s,\n          y: 100\n        }, i), o += e.x + \"px \" + e.y + \"px, \";\n      }\n      o = o.slice(0, -2), o += \")\";\n      const a = `\\n            display: block;\\n            z-index: ${(this.getSettings().startZIndex + 10).toString(10)};\\n            width: ${this.shadow.width}px;\\n            height: ${2 * t.height}px;\\n            background: linear-gradient(${n}, rgba(0, 0, 0, ${this.shadow.opacity}), rgba(0, 0, 0, 0));\\n            transform-origin: ${s}px 100px;\\n            transform: translate3d(${e.x - s}px, ${e.y - 100}px, 0) rotate(${i}rad);\\n            clip-path: ${o};\\n            -webkit-clip-path: ${o};\\n        `;\n      this.outerShadow.style.cssText = a;\n    }\n    drawLeftPage() {\n      \"portrait\" !== this.orientation && null !== this.leftPage && (1 === this.direction && null !== this.flippingPage && \"hard\" === this.flippingPage.getDrawingDensity() ? (this.leftPage.getElement().style.zIndex = (this.getSettings().startZIndex + 5).toString(10), this.leftPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle()), this.leftPage.draw(this.flippingPage.getDrawingDensity())) : this.leftPage.simpleDraw(0));\n    }\n    drawRightPage() {\n      null !== this.rightPage && (0 === this.direction && null !== this.flippingPage && \"hard\" === this.flippingPage.getDrawingDensity() ? (this.rightPage.getElement().style.zIndex = (this.getSettings().startZIndex + 5).toString(10), this.rightPage.setHardDrawingAngle(180 + this.flippingPage.getHardAngle()), this.rightPage.draw(this.flippingPage.getDrawingDensity())) : this.rightPage.simpleDraw(1));\n    }\n    drawBottomPage() {\n      if (null === this.bottomPage) return;\n      const t = null != this.flippingPage ? this.flippingPage.getDrawingDensity() : null;\n      \"portrait\" === this.orientation && 1 === this.direction || (this.bottomPage.getElement().style.zIndex = (this.getSettings().startZIndex + 3).toString(10), this.bottomPage.draw(t));\n    }\n    drawFrame() {\n      this.clear(), this.drawLeftPage(), this.drawRightPage(), this.drawBottomPage(), null != this.flippingPage && (this.flippingPage.getElement().style.zIndex = (this.getSettings().startZIndex + 5).toString(10), this.flippingPage.draw()), null != this.shadow && null !== this.flippingPage && (\"soft\" === this.flippingPage.getDrawingDensity() ? (this.drawOuterShadow(), this.drawInnerShadow()) : (this.drawHardOuterShadow(), this.drawHardInnerShadow()));\n    }\n    clear() {\n      for (const t of this.app.getPageCollection().getPages()) t !== this.leftPage && t !== this.rightPage && t !== this.flippingPage && t !== this.bottomPage && (t.getElement().style.cssText = \"display: none\"), t.getTemporaryCopy() !== this.flippingPage && t.hideTemporaryCopy();\n    }\n    update() {\n      super.update(), null !== this.rightPage && this.rightPage.setOrientation(1), null !== this.leftPage && this.leftPage.setOrientation(0);\n    }\n  }\n  class x {\n    constructor() {\n      this._default = {\n        startPage: 0,\n        size: \"fixed\",\n        width: 0,\n        height: 0,\n        minWidth: 0,\n        maxWidth: 0,\n        minHeight: 0,\n        maxHeight: 0,\n        drawShadow: !0,\n        flippingTime: 1e3,\n        usePortrait: !0,\n        startZIndex: 0,\n        autoSize: !0,\n        maxShadowOpacity: 1,\n        showCover: !1,\n        mobileScrollSupport: !0,\n        swipeDistance: 30,\n        clickEventForward: !0,\n        useMouseEvents: !0,\n        showPageCorners: !0,\n        disableFlipByClick: !1\n      };\n    }\n    getSettings(t) {\n      const e = this._default;\n      if (Object.assign(e, t), \"stretch\" !== e.size && \"fixed\" !== e.size) throw new Error('Invalid size type. Available only \"fixed\" and \"stretch\" value');\n      if (e.width <= 0 || e.height <= 0) throw new Error(\"Invalid width or height\");\n      if (e.flippingTime <= 0) throw new Error(\"Invalid flipping time\");\n      return \"stretch\" === e.size ? (e.minWidth <= 0 && (e.minWidth = 100), e.maxWidth < e.minWidth && (e.maxWidth = 2e3), e.minHeight <= 0 && (e.minHeight = 100), e.maxHeight < e.minHeight && (e.maxHeight = 2e3)) : (e.minWidth = e.width, e.maxWidth = e.width, e.minHeight = e.height, e.maxHeight = e.height), e;\n    }\n  }\n  !function (t, e) {\n    void 0 === e && (e = {});\n    var i = e.insertAt;\n    if (t && \"undefined\" != typeof document) {\n      var s = document.head || document.getElementsByTagName(\"head\")[0],\n        n = document.createElement(\"style\");\n      n.type = \"text/css\", \"top\" === i && s.firstChild ? s.insertBefore(n, s.firstChild) : s.appendChild(n), n.styleSheet ? n.styleSheet.cssText = t : n.appendChild(document.createTextNode(t));\n    }\n  }(\".stf__parent {\\n  position: relative;\\n  display: block;\\n  box-sizing: border-box;\\n  transform: translateZ(0);\\n\\n  -ms-touch-action: pan-y;\\n  touch-action: pan-y;\\n}\\n\\n.sft__wrapper {\\n  position: relative;\\n  width: 100%;\\n  box-sizing: border-box;\\n}\\n\\n.stf__parent canvas {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  left: 0;\\n  top: 0;\\n}\\n\\n.stf__block {\\n  position: absolute;\\n  width: 100%;\\n  height: 100%;\\n  box-sizing: border-box;\\n  perspective: 2000px;\\n}\\n\\n.stf__item {\\n  display: none;\\n  position: absolute;\\n  transform-style: preserve-3d;\\n}\\n\\n.stf__outerShadow {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\\n\\n.stf__innerShadow {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\\n\\n.stf__hardShadow {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\\n\\n.stf__hardInnerShadow {\\n  position: absolute;\\n  left: 0;\\n  top: 0;\\n}\");\n  t.PageFlip = class extends class {\n    constructor() {\n      this.events = new Map();\n    }\n    on(t, e) {\n      return this.events.has(t) ? this.events.get(t).push(e) : this.events.set(t, [e]), this;\n    }\n    off(t) {\n      this.events.delete(t);\n    }\n    trigger(t, e, i = null) {\n      if (this.events.has(t)) for (const s of this.events.get(t)) s({\n        data: i,\n        object: e\n      });\n    }\n  } {\n    constructor(t, e) {\n      super(), this.isUserTouch = !1, this.isUserMove = !1, this.setting = null, this.pages = null, this.setting = new x().getSettings(e), this.block = t;\n    }\n    destroy() {\n      this.ui.destroy(), this.block.remove();\n    }\n    update() {\n      this.render.update(), this.pages.show();\n    }\n    loadFromImages(t) {\n      this.ui = new u(this.block, this, this.setting);\n      const e = this.ui.getCanvas();\n      this.render = new d(this, this.setting, e), this.flipController = new g(this.render, this), this.pages = new n(this, this.render, t), this.pages.load(), this.render.start(), this.pages.show(this.setting.startPage), setTimeout(() => {\n        this.ui.update(), this.trigger(\"init\", this, {\n          page: this.setting.startPage,\n          mode: this.render.getOrientation()\n        });\n      }, 1);\n    }\n    loadFromHTML(t) {\n      this.ui = new c(this.block, this, this.setting, t), this.render = new w(this, this.setting, this.ui.getDistElement()), this.flipController = new g(this.render, this), this.pages = new o(this, this.render, this.ui.getDistElement(), t), this.pages.load(), this.render.start(), this.pages.show(this.setting.startPage), setTimeout(() => {\n        this.ui.update(), this.trigger(\"init\", this, {\n          page: this.setting.startPage,\n          mode: this.render.getOrientation()\n        });\n      }, 1);\n    }\n    updateFromImages(t) {\n      const e = this.pages.getCurrentPageIndex();\n      this.pages.destroy(), this.pages = new n(this, this.render, t), this.pages.load(), this.pages.show(e), this.trigger(\"update\", this, {\n        page: e,\n        mode: this.render.getOrientation()\n      });\n    }\n    updateFromHtml(t) {\n      const e = this.pages.getCurrentPageIndex();\n      this.pages.destroy(), this.pages = new o(this, this.render, this.ui.getDistElement(), t), this.pages.load(), this.ui.updateItems(t), this.render.reload(), this.pages.show(e), this.trigger(\"update\", this, {\n        page: e,\n        mode: this.render.getOrientation()\n      });\n    }\n    clear() {\n      this.pages.destroy(), this.ui.clear();\n    }\n    turnToPrevPage() {\n      this.pages.showPrev();\n    }\n    turnToNextPage() {\n      this.pages.showNext();\n    }\n    turnToPage(t) {\n      this.pages.show(t);\n    }\n    flipNext(t = \"top\") {\n      this.flipController.flipNext(t);\n    }\n    flipPrev(t = \"top\") {\n      this.flipController.flipPrev(t);\n    }\n    flip(t, e = \"top\") {\n      this.flipController.flipToPage(t, e);\n    }\n    updateState(t) {\n      this.trigger(\"changeState\", this, t);\n    }\n    updatePageIndex(t) {\n      this.trigger(\"flip\", this, t);\n    }\n    updateOrientation(t) {\n      this.ui.setOrientationStyle(t), this.update(), this.trigger(\"changeOrientation\", this, t);\n    }\n    getPageCount() {\n      return this.pages.getPageCount();\n    }\n    getCurrentPageIndex() {\n      return this.pages.getCurrentPageIndex();\n    }\n    getPage(t) {\n      return this.pages.getPage(t);\n    }\n    getRender() {\n      return this.render;\n    }\n    getFlipController() {\n      return this.flipController;\n    }\n    getOrientation() {\n      return this.render.getOrientation();\n    }\n    getBoundsRect() {\n      return this.render.getRect();\n    }\n    getSettings() {\n      return this.setting;\n    }\n    getUI() {\n      return this.ui;\n    }\n    getState() {\n      return this.flipController.getState();\n    }\n    getPageCollection() {\n      return this.pages;\n    }\n    startUserTouch(t) {\n      this.mousePosition = t, this.isUserTouch = !0, this.isUserMove = !1;\n    }\n    userMove(t, e) {\n      this.isUserTouch || e || !this.setting.showPageCorners ? this.isUserTouch && h.GetDistanceBetweenTwoPoint(this.mousePosition, t) > 5 && (this.isUserMove = !0, this.flipController.fold(t)) : this.flipController.showCorner(t);\n    }\n    userStop(t, e = !1) {\n      this.isUserTouch && (this.isUserTouch = !1, e || (this.isUserMove ? this.flipController.stopMove() : this.flipController.flip(t)));\n    }\n  }, Object.defineProperty(t, \"__esModule\", {\n    value: !0\n  });\n});","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}